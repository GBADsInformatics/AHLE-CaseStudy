#%% Contents
# -----------------------------------------------------------------------------------------------
# ### Framework
# 1. Startup & Imports
# 2. Initialize App (i.e., the web app)
# 3. Global Program Elements (e.g. read in data and prep it)
# 4. Layout (i.e, the UI layout)
# 5. Callbacks (functions that respond to UI)
# 6. Run App
# -----------------------------------------------------------------------------------------------

#%% 1. STARTUP & IMPORTS

# standard library packages (included with python and always available)
import os, sys, datetime as dt
from pathlib import Path
import inspect
import requests
import io

print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] Starting {__name__}")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] cwd = {os.getcwd()}")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] {sys.path[:2] = }")
print(f"[{dt.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:19]}] {sys.version = }")

# Third party packages (ie, those installed with pip )
# NO NEED to import Dash or JupyterDash here.  That is done within fa.instantiate_app

from dash import html, dcc, Input, Output, State, dash_table, ctx
import dash_bootstrap_components as dbc  # Allows easy access to all bootstrap themes
import dash_daq as daq
import dash_auth
import numpy as np
import scipy as sp
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import geopandas as gpd
from flask import Flask, redirect
# private (fa) libraries
import lib.fa_dash_utils as fa

#### PARAMETERS
prod                         = False   # Use when testing/dev mode to remove auth

#%% 2. INITIALIZE APP
###############################################################################################
# - App named here... if name is changed here, must also be changed elsewhere below
# - Either JupyterDash or just Dash for traditional .py program in Spyder. (Latter requires: 'from dash import Dash' above)
# - There are other dbc.themes (e.g. "SANDSTONE") and other options besides dash_bootstrap_components
###############################################################################################
app_title = 'AHLE Case Study Dash UI'
external_stylesheets=[dbc.themes.BOOTSTRAP]
flask_server, app = fa.instantiate_app(app_title, external_stylesheets) # dont change name "flask_server".  Gunicorn expects to find it
gbadsDash = app  # an alias for app; the app name used within this program

if prod:
    ## USERNAMES AND PASSWORDS
    # Keep this out of source code repository - save in a file or a database
    VALID_USERNAME_PASSWORD_PAIRS = {
        'gbads': 'welcometogbads',
        'GBADS': "welcometogbads",
        'GBADs': "welcometogbads"
    }

    # BASIC AUTHORIZATION:  USERNAME:PASSWORD
    auth = dash_auth.BasicAuth(
        gbadsDash,
        VALID_USERNAME_PASSWORD_PAIRS
        )


app.config.suppress_callback_exceptions = True    # Use to remove warnings when assigning callbacks to components that are generated by other callbacks (and therefore not in the initial layout)

#%% 3. GLOBAL PROGRAM ELEMENTS
###############################################################################################
# - Global variables and functions that aren't directly involved in the UI interactivity (Callbacks)
# - Typical example would be functions that read, store, and prep data to be used in the app
###############################################################################################
# Define tab styles

# Tab colors based on grouping
ecs_tab_style = {
    'backgroundColor': '#d7bce1',
    'border-color': 'grey',
    'fontWeight': 'bold'
}
ecs_tab_selected_style = {
    'backgroundColor': '#d7bce1',
    'border-color': 'grey',
    'fontWeight': 'bold'
}

user_guide_tab_style ={
    'border-color': 'grey',
    'fontWeight': 'bold'
}

user_guide_tab_selected_style ={
    'border-color': 'grey',
    'fontWeight': 'bold'
}


# =============================================================================
# # For reference, the first version of the plots was based on Excel files
#
# # Data for the waterfall chart
# waterfall_df = pd.read_excel("data/chickens_bod_plotdata.xls", header=0,sheet_name="Waterfall")
#
# # Data for the sankey diagram
# sankey_df = pd.read_excel("data/chickens_bod_plotdata.xls", header=0,sheet_name="Sankey")
#
# # Data for the data table
# background_df = pd.read_excel('data/chickens_bod_backgrounddata.xls')
#
# =============================================================================

# =============================================================================
#### Read data
# =============================================================================
# Define folder location
CWD = os.getcwd()
DASH_DATA_FOLDER = os.path.join(CWD ,'data')

# Folder location for ethiopia case study
GBADsLiverpool=Path(os.getcwd()).parent.parent
Data_and_Processing_Code = "Data and Processing Code"

# Folder location for global aggregate
if prod:
    # Output folders:
    ECS_PROGRAM_OUTPUT_FOLDER = os.path.join(CWD, Data_and_Processing_Code, "Program outputs")
else:
    # Output folders:
    ECS_PROGRAM_OUTPUT_FOLDER = os.path.join(GBADsLiverpool, Data_and_Processing_Code, "Program outputs")

# -----------------------------------------------------------------------------
# Ethiopia Case Study
# -----------------------------------------------------------------------------
# Compartmental model results summary
ecs_ahle_summary = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_summary.csv'))
## Using alternative data which summarizes results from age/sex specific scenarios
ahle_all_scensmry = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_scensmry.csv'))

# Compartmental model results summary with AHLE calculated
# for stacked bar
ecs_ahle_summary2 = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_summary2.csv'))

# Attribution Summary
# ecs_ahle_all_withattr = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_withattr.csv'))
## Using data with disease-specific attribution
ecs_ahle_all_withattr = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'ahle_all_withattr_disease.csv'))

# JR 2023-4-19: added regional results. Testing with Nationl level (should be same as before).
# ahle_all_scensmry = ahle_all_scensmry.query("region == 'National'").copy()
ecs_ahle_summary2 = ecs_ahle_summary2.query("region == 'National'")
# ecs_ahle_all_withattr = ecs_ahle_all_withattr.query("region == 'National'")

# Ethiopia geojson files from S3
# Regional level
url = 'https://gbads-data-repo.s3.ca-central-1.amazonaws.com/shape-files/eth_admbnda_adm1_csa_bofedb_2021.geojson'
r = requests.get(url, allow_redirects=True)
geojson_ecs = r.json()

# Alternative: read from local copy
# geojson_ecs = gpd.read_file(os.path.join(DASH_DATA_FOLDER ,'eth_admbnda_adm1_csa_bofedb_2021.geojson'))

# Expert opinion files
ecs_expertattr_smallrum = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_smallruminants.csv'))
ecs_expertattr_cattle = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_cattle.csv'))
ecs_expertattr_poultry = pd.read_csv(os.path.join(DASH_DATA_FOLDER ,'attribution_experts_chickens.csv'))

# Economic data is very simple. From Dashboard WEI 08082023.xlsx shared by Tom Marsh
wei_ethiopia_raw = pd.DataFrame({
    'species':'Cattle and Small Ruminants'
    ,'scenario':['Current' ,'Zero Mortality' ,'Ideal']
    ,'scenario_numeric':[0 ,0.5 ,1]
    ,'production_change_pct':[0 ,.402 ,1.8048]
    ,'gdp_change_pct':[0 ,.0251 ,.0357]
    ,'economic_surplus_mlnusd':[0 ,1760.050 ,2452.180]
})

# =============================================================================
#### User options and defaults
# =============================================================================
# -----------------------------------------------------------------------------
# All species
# -----------------------------------------------------------------------------
# Region options
region_structure_options = [{'label': i, 'value': i, 'disabled': False} for i in ["WOAH",
                                                                       "FAO",
                                                                       "World Bank",]]

# WOAH regions
WOAH_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Africa",
                                                                       "Americas",
                                                                       "Asia, Far East and Oceania",
                                                                       "Europe"
                                                                       ]]
WOAH_region_options += [{'label': "Middle East", 'value': "Middle East", 'disabled': True}]  # Include, but disable, Middle East

# WOAH region-country mapping
WOAH_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

WOAH_americas_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil",
                                                                          "United States of America"]]

WOAH_asia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India",
                                                                          "United States of America"]]

WOAH_europe_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

# FAO regions
fao_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Africa",
                                                                       "Asia",
                                                                       "Europe and Central Asia",
                                                                       "Latin America and the Caribbean",
                                                                       "South West Pacific"
                                                                       ]]

fao_region_options += [{'label': "Near East and North Africa", 'value': "Near East and North Africa", 'disabled': True}]  # Include, but disable, Middle East

# FAO region-country mapping
fao_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

fao_asia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India"]]

fao_eca_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

fao_lac_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil"]]

fao_swp_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                          "United States of America"]]

# World Bank regions
wb_region_options = [{'label': i, 'value': i, 'disabled': False} for i in ["All",
                                                                        "Sub-Saharan Africa",
                                                                       "Europe & Central Asia",
                                                                       "Latin America & the Caribbean",
                                                                       "North America",
                                                                       "South Asia"
                                                                       ]]

wb_region_options += [{'label': i, 'value': i, 'disabled': True} for i in ["East Asia & Pacific",
                                                                       "Middle East & North Africa"
                                                                       ]]

# World Bank region-country mapping

wb_africa_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Ethiopia"]]

wb_eca_options = [{'label': i, 'value': i, 'disabled': False} for i in ["France",
                                                                        "Germany",
                                                                       "Italy",
                                                                       "Netherlands",
                                                                       "Poland",
                                                                       "United Kingdom"]]

wb_lac_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Brazil"]]

wb_na_options = [{'label': i, 'value': i, 'disabled': False} for i in ["United States of America"]]

wb_southasia_options = [{'label': i, 'value': i, 'disabled': False} for i in ["India"]]


# Define country shortnames
# These taken from https://en.wikipedia.org/wiki/List_of_alternative_country_names
# Keys in this dictionary must match country names in data
# Should include superset of countries from all species
country_shortnames = {
   'Brazil':'BRA'
   ,'China':'CHN'
   ,'Denmark':'DNK'
   ,'France':'FRA'
   ,'Germany':'DEU'
   ,'India':'IND'
   ,'Italy':'ITA'
   ,'Netherlands':'NLD'
   ,'Poland':'POL'
   ,'Russia':'RUS'
   ,'Spain':'ESP'
   ,'United Kingdom':'GBR'
   ,'United States of America':'USA'
}

# Metrics
# Labels are shown in dropdown, Values are shown in plot titles
# Values must match column names created in prep_bod_forwaterfall()
metric_options = [
   {'label':"Tonnes", 'value':"tonnes", 'disabled':False}
   ,{'label':"US Dollars", 'value':"US dollars", 'disabled':False}
   ,{'label':"Percent of GDP", 'value':"percent of GDP", 'disabled':False}
   ,{'label':"Percent of Breed Standard", 'value':"percent of breed standard", 'disabled':False}
   ,{'label':"Percent of Realised Production", 'value':"percent of realised production", 'disabled':False}
]

# =============================================================================
#### Ethiopia case study options
# =============================================================================
# Species
# ecs_species_options = []
# for i in np.sort(ecs_ahle_summary['species'].unique()):
#     str(ecs_species_options.append({'label':i,'value':(i)}))
# Specify the order of the species
ecs_species_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Cattle",
                                                                             "All Small Ruminants",
                                                                             "Goat",
                                                                             "Sheep",
                                                                             "All Poultry",
                                                                             "Poultry hybrid",
                                                                             "Poultry indigenous",
                                                                             ]]

# Production system
# Rename Overall to more descriptive
ecs_ahle_summary['production_system'] = ecs_ahle_summary['production_system'].replace({'Overall': 'All Production Systems'})

# ecs_prodsys_options are now defined dynamically in a callback based on selected species
# ecs_prodsys_options = []
# for i in np.sort(ecs_ahle_summary['production_system'].unique()):
#    str(ecs_prodsys_options.append({'label':i,'value':(i)}))

# Year
# Year options are now set in a callback
# ecs_year_options=[]
# for i in np.sort(ecs_ahle_summary['year'].unique()):
#     str(ecs_year_options.append({'label':i,'value':(i)}))

# Sex
ecs_agesex_options=[]
for i in np.sort(ecs_ahle_summary['group'].unique()):
   str(ecs_agesex_options.append({'label':i,'value':(i)}))

# Currency
ecs_currency_options = [{'label': "Birr", 'value': "Birr", 'disabled': False},
                        {'label': "USD", 'value': "USD", 'disabled': False}]

# Attribution hierarchy
ecs_hierarchy_attr_options = [{'label': "Cause", 'value': "cause", 'disabled': False},
                              {'label': "Production System", 'value': "production_system", 'disabled': False},
                              {'label': "Age Group", 'value': "age_group", 'disabled': False},
                              {'label': "Sex", 'value': "sex", 'disabled': False},
                              {'label': "AHLE Component", 'value': "ahle_component", 'disabled': False},
                              {'label': "Disease", 'value': "disease", 'disabled': False}
                              ]

# Drill down options for hierarchy
ecs_hierarchy_dd_attr_options = [{'label': i, 'value': i, 'disabled': False} for i in ["None"]]
ecs_hierarchy_dd_attr_options += ecs_hierarchy_attr_options

# Region - removing 'National' from the options
ecs_region_options = []
for i in ecs_ahle_summary.query("region != 'National'").region.unique():
    str(ecs_region_options.append({'label':i,'value':(i)}))

# Display
ecs_display_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Difference",
                                                                             "Side by Side",
                                                                            ]]
# Item

# Compare
ecs_compare_options = [{'label': i, 'value': i, 'disabled': False} for i in ["Ideal",
                                                                             "Zero Mortality",
                                                                             "Improvement"
                                                                             ]]
# August 2023: updated scenarios do not include zero mortality or improvement
ecs_compare_options_limited = [
    {'label': "Ideal", 'value': "Ideal", 'disabled': False}
    ,{'label': "Zero Mortality", 'value': "Zero Mortality", 'disabled': True}
    ,{'label': "Improvement", 'value': "Improvement", 'disabled': True}
    ]

# Factor
ecs_factor_options = [{'label': i, 'value': i, 'disabled': True} for i in ["Mortality",
                                                                           "Live Weight",
                                                                           "Parturition Rate",
                                                                           "Lactation"
                                                                           ]]

# Reduction
ecs_improve_options = [{'label': i, 'value': i, 'disabled': True} for i in ['25%',
                                                                            '50%',
                                                                            '75%',
                                                                            '100%',
                                                                            ]]
# Map Denominator
ecs_map_denominator_options = [{'label': i, 'value': i, 'disabled': False} for i in ['Per kg biomass',
                                                                                     'Total',
                                                                                     ]]

# =============================================================================
#### Prep data for plots
# =============================================================================
def prep_ahle_fortreemap_ecs(INPUT_DF):
   ecs_ahle_attr_treemap = INPUT_DF.copy()

   # # Trim the data to keep things needed for the treemap
   # ecs_ahle_attr_treemap = working_df[[
   #     'species',
   #     'production_system',
   #     'age_group',
   #     'sex',
   #     'year',
   #     'ahle_component',
   #     'cause',
   #     'disease',
   #     'mean',
   #     # 'pct_of_total'
   #     ]]

   # Can only have positive values
   ecs_ahle_attr_treemap['mean'] = abs(ecs_ahle_attr_treemap['mean'])

   # Replace 'overall' values with more descriptive values
   # ecs_ahle_summary_tree_pivot['age_group'] = ecs_ahle_summary_tree_pivot['age_group'].replace({'Overall': 'Overall Age'})
   ecs_ahle_attr_treemap['sex'] = ecs_ahle_attr_treemap['sex'].replace({'Overall': 'Overall Sex'})

   # Replace mortality with mortality loss
   ecs_ahle_attr_treemap['ahle_component'] = ecs_ahle_attr_treemap['ahle_component'].replace({'Mortality': 'Mortality Loss'})

   # Fill in missing values with 0
   ecs_ahle_attr_treemap = ecs_ahle_attr_treemap.fillna(0)

   OUTPUT_DF = ecs_ahle_attr_treemap

   return OUTPUT_DF


def prep_ahle_forwaterfall_ecs(INPUT_DF):
   ecs_ahle_waterfall = INPUT_DF.copy()

   # Fill missing values with 0
   ecs_ahle_waterfall.fillna(0)

   # Keep only items for the waterfall
   # This also specifies the ordering of the bars
   waterfall_plot_items = ('Value of Offtake',
                            'Value of Eggs consumed',
                            'Value of Eggs sold',
                            'Value of Herd Increase',
                            'Value of draught',
                            'Value of Milk',
                            'Value of Manure',
                            'Value of Hides',
                            'Feed Cost',
                            'Labour Cost',
                            'Health Cost',
                            'Infrastructure Cost',
                            'Capital Cost',
                            'Gross Margin')
   waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
   ecs_ahle_waterfall = ecs_ahle_waterfall.loc[ecs_ahle_waterfall['item'].str.upper().isin(waterfall_plot_items_upper)]

   # Sort Item column to keep values and costs together
   ecs_ahle_waterfall['item'] = ecs_ahle_waterfall['item'].astype('category')
   ecs_ahle_waterfall.item.cat.set_categories(waterfall_plot_items, inplace=True)
   ecs_ahle_waterfall = ecs_ahle_waterfall.sort_values(["item"])

   # Rename costs values to be more descriptive
   ecs_ahle_waterfall['item'] = ecs_ahle_waterfall['item'].replace({'Feed Cost': 'Expenditure on Feed',
                                                                    'Labour Cost': 'Expenditure on Labour',
                                                                    'Health Cost': 'Expenditure on Health',
                                                                    'Infrastructure Cost': 'Expenditure on Housing',
                                                                    'Capital Cost': 'Expenditure on Capital',
                                                                    'Value of draught': 'Value of Draught'})

   OUTPUT_DF = ecs_ahle_waterfall

   return OUTPUT_DF

def prep_ahle_forstackedbar_ecs(INPUT_DF, cols_birr_costs, cols_usd_costs, pretty_ahle_cost_names):
   working_df = INPUT_DF.copy()

   # Birr costs
   # Ordering here determines order in plot
   cols_birr_costs = cols_birr_costs

   # USD costs
   cols_usd_costs = cols_usd_costs

   # If any costs are missing, fill in zero
   for COL in cols_birr_costs + cols_usd_costs:
      working_df[COL] = working_df[COL].replace(np.nan ,0)

   # Melt birr costs into rows
   output_birr = working_df.melt(
      id_vars=['species' ,'production_system']
      ,value_vars=cols_birr_costs
      ,var_name='ahle_due_to'
      ,value_name='cost_birr'
   )
   # output_actual['opt_or_act'] = 'Actual'  # Value here determines bar label in plot

   # Melt usd costs into rows
   output_usd = working_df.melt(
      id_vars=['species' ,'production_system']
      ,value_vars=cols_usd_costs
      ,var_name='ahle_due_to'
      ,value_name='cost_usd'
   )
   # output_ideal['opt_or_act'] = 'Ideal + Burden of disease'  # Value here determines bar label in plot

   # Stack
   OUTPUT_DF = pd.concat(
      [output_birr ,output_usd]
      ,axis=0
      ,join='outer'
      ,ignore_index=True
   )

   # Recode cost item names
   pretty_ahle_cost_names = pretty_ahle_cost_names
   OUTPUT_DF['AHLE Due To'] = OUTPUT_DF['ahle_due_to'].replace(pretty_ahle_cost_names)

   # Create new string column for label
   OUTPUT_DF['Age_group_string'] = OUTPUT_DF['ahle_due_to'].str.slice(10,12)
   OUTPUT_DF['Age_group_string'] = OUTPUT_DF['Age_group_string'].str.upper()

   # Add column with labels for each segment
   OUTPUT_DF['label_birr'] = OUTPUT_DF['Age_group_string'] + ' - ' + OUTPUT_DF['cost_birr'].map('{:,.0f}'.format).astype(str) + ' Birr'
   OUTPUT_DF['label_usd'] = OUTPUT_DF['Age_group_string'] + ' - ' + OUTPUT_DF['cost_usd'].map('{:,.0f}'.format).astype(str) + ' USD'

   return OUTPUT_DF

# =============================================================================
#### Define the figures
# =============================================================================
# Define the Waterfall
def create_waterfall(x, y, text):
     waterfall_fig = go.Figure(go.Waterfall(
        name = "20",
        orientation = "v",

        measure = ["relative", "relative", "relative", "relative", "total"],  # This needs to change with number of columns in waterfalll
        x=x,
        y=y,
        hoverinfo = 'none',  # Disable the hover over tooltip
        text=text,
        textposition = ["outside","outside","auto","auto","outside"],
        decreasing = {'marker':{"color":'#F7931D'}},
        increasing = {'marker':{"color":'#3598DB'}},
        totals = {'marker':{"color":'#5BC0DE'}},
        connector = {"line":{"color":"darkgrey"}}#"rgb(63, 63, 63)"}},
        ))

     waterfall_fig.update_layout(clickmode='event+select', ### EVENT SELECT ??????
                                 plot_bgcolor="#ededed")
     waterfall_fig.update_xaxes(
         fixedrange=True
         )
     waterfall_fig.update_yaxes(
         fixedrange=True
         )

     return waterfall_fig

# Define the Sankey
def create_sankey(label_list, color, x, y, source, target, values, n):
    sankey_fig = go.Figure(data=go.Sankey(
        textfont = dict(size=15),
        arrangement = 'fixed',
        hoverinfo = 'none',  # Disable the hover over tooltip
        valueformat = ",.0f",
        node = dict(
            pad = 25,
            thickness = 15,
            line = dict(color = "black", width = 0.5),
            label = label_list,
            x = x,
            y = y,
            color = color
            ),
        link = dict(
            source = source,
            target = target,
            value = values,
            color = ['#ededed']*n),
        ))
    return sankey_fig

# Define the attribution treemap
def create_attr_treemap_ecs(input_df, path):
    treemap_fig = px.treemap(
        input_df,
        # path=[
        #    'cause',
        #    'production_system',
        #    'age_group',
        #    'sex',
        #    'ahle_component',
        #    ],
        path = path,
        values='mean',
        # hover_data=['pct_of_total'],
        # custom_data=['pct_of_total'],
        color='cause',            # cause only applys to the cause level
        color_discrete_map={      # Cause colors match the Human health dashboard
            '(?)':'lightgrey',
            'Infectious':'#68000D',
            'Non-infectious':'#08316C',
            'External':'#00441B'
            }
        )

    return treemap_fig

# Define the AHLE waterfall
def create_ahle_waterfall_ecs(input_df, name, measure, x, y):
    waterfall_fig = go.Figure(go.Waterfall(
        name = name,
        orientation = "v",
        measure = measure,  # This needs to change with number of columns in waterfalll
        x=x,
        y=y,
        decreasing = {'marker':{"color":'#E84C3D'}},
        increasing = {'marker':{"color":'#3598DB'}},
        totals = {'marker':{"color":'#F7931D'}},
        connector = {"line":{"color":"darkgrey"}},
        customdata=np.stack((y, input_df['item']), axis=-1),
        ))

    waterfall_fig.update_layout(clickmode='event+select', ### EVENT SELECT ??????
                                plot_bgcolor="#ededed",)

    waterfall_fig.add_annotation(x=4, xref='x',         # x position is absolute on axis
                                 y=0, yref='paper',     # y position is relative [0,1] to work regardless of scale
                                 text="Source: GBADs",
                                 showarrow=False,
                                 yshift=10,
                                 font=dict(
                                     family="Helvetica",
                                     size=18,
                                     color="black"
                                     )
                                 )
    waterfall_fig.update_xaxes(
        fixedrange=True
        )
    waterfall_fig.update_yaxes(
        fixedrange=True
        )

    return waterfall_fig

# Define the stacked bar
def create_stacked_bar_ecs(input_df, x, y, text, color, yaxis_title):
    bar_fig = px.bar(
        input_df,
        x=x,
        y=y,
        text = text,
        color=color,
        color_discrete_map={
          "Neonatal male":"#2A80B9",
          "Neonatal":"#2A80B9",
          "Neonatal female":"#6eb1de",
          "Juvenile male":"#9B58B5",
          "Juvenile":"#9B58B5",
          "Juvenile female":"#caa6d8",
          "Adult male":"#2DCC70",
          "Adult female":"#82e3aa",
          })
    bar_fig.update_layout(
        plot_bgcolor="#ededed",
        hovermode=False,
        showlegend=True,
        xaxis_title=None,
        yaxis_title=yaxis_title,
        )
    bar_fig.update_xaxes(
        fixedrange=True
        )
    bar_fig.update_yaxes(
        fixedrange=True
        )
    return bar_fig

# Define Ethiopia subnation level map
def create_map_display_ecs(input_df, geojson, location, featurekey, color_by, color_scale):
    ecs_map_fig = px.choropleth_mapbox(input_df,
                                       geojson=geojson,
                                       locations=location,
                                       featureidkey=featurekey,
                                       color=color_by,
                                       color_continuous_scale=color_scale,
                                       opacity=0.7,
                                       mapbox_style="carto-positron",
                                       zoom=5,
                                       center = {"lat": 9.1450, "lon": 40.4897},
                                       labels={'region': 'State',
                                               'mean_current': 'Current',
                                               'mean_ideal': 'Ideal',
                                               'mean_diff_ideal': 'AHLE'}
                                       )

    return ecs_map_fig

# Wider Economic Impact charts for Ethiopia
def create_wei_chart(
        input_df                # Dataframe
        ,plot_xvar              # String: variable to use for x axis
        ,plot_yvar              # String: variable to use for y axis. Will be interpolated over range min(X), max(X).
        ,plot_color
        ,interpolation_kind     # 'linear', 'quadratic', or 'cubic'. Integer n: spline of order n.
        ,yvar_divisor=None      # Divide y values by this number before interpolation and plotting
    ):
    # Generate range of x-axis values
    gen_end = input_df[plot_xvar].max()
    step_size = 0.01
    gen_num = int(input_df[plot_xvar].max() / step_size)
    gen_x = np.linspace(
    	start=0 				# Start value. Can be integer or float.
    	,stop=gen_end 				# Stop value. Can be integer or float.
    	,num=gen_num 				# Number of elements to generate. Will be evenly spaced from START to STOP.
        )
    # Create dataframe and name generated data for predictor variable
    gen_x_df = pd.DataFrame({
        plot_xvar:gen_x
    })

    # Adjust scale
    if yvar_divisor:
        input_df[plot_yvar] = input_df[plot_yvar] / yvar_divisor

    # Get interpolation line
    interpolator = sp.interpolate.interp1d(
        input_df[plot_xvar]
        ,input_df[plot_yvar]
        ,kind=interpolation_kind
        )
    interp_y = interpolator(gen_x)		# Calculate y-axis values on fit line
    gen_x_df[plot_yvar] = interp_y

    # Plot data
    fig = px.scatter(
        input_df
        ,x=plot_xvar
        ,y=plot_yvar
        ,text='scenario'
        ,hover_name='scenario'
        ,hover_data={
            'scenario':False    # Used for hover name, remove from hover data
            }
        )
    fig.update_traces(
        marker_size=20
        ,marker_color=plot_color
        ,textposition='top center'
        )

    # Plot fit line
    fig_interp = px.scatter(
        gen_x_df
        ,x=plot_xvar
        ,y=plot_yvar
        )
    fig_interp.update_traces(
        mode='lines'
        ,line_width=2
        ,line_color=plot_color
        )
    fig.add_trace(fig_interp.data[0])

    # Draw
    fig.update_layout(xaxis_title=plot_xvar ,yaxis_title=plot_yvar)
    fig.update_xaxes(dtick=0.2)
    return fig

# This function creates a plotly treemap with an option to show weighted averages
# instead of sums for boxes above the base level.
# It first calculates weighted averages using a pivot table, then draws the treemap by
# specifying the id and parent for each box.
# 2023/3/22: There is a bug causing a blank chart when AGGREGATION == 'mean'. Not using this at this time.
def create_treemap_withagg(
        INPUT_DF
        ,HIERARCHY              # List: categorical variables that define hierarchy, in desired order most to least aggregated
        ,COLOR_BY               # String: variable to color by. WARNING: must be one of the variables in HIERARCHY.
        ,VALUE_VAR              # String: variable with values to plot
        ,AGGREGATION='sum'      # String: how to aggregate VALUE_VAR. 'sum' (default) or 'mean'.
        ,WEIGHT_VAR=None        # String (optional): variable to use for weighting if AGGREGATION='mean'.
    ):
    if AGGREGATION == 'mean':
        dfmod = INPUT_DF.copy()

        # Create weighted value
        if WEIGHT_VAR:
            dfmod['treemap_weight'] = dfmod[WEIGHT_VAR]
        else:
            dfmod['treemap_weight'] = 1
        dfmod['treemap_weighted_value'] = dfmod[VALUE_VAR] * dfmod['treemap_weight']

        # For each variable in the hierarchy, create summary rows where that variable is ALL
        # Calculate the mean of the weighted value
        treemap_df = pd.DataFrame()     # Initialize dataframe to hold results
        for i ,VAR in enumerate(HIERARCHY):
            summary_rows = dfmod.pivot_table(
                index=HIERARCHY[:i+1]     # Index is all hierarchy variables up to i
                ,values=['treemap_weighted_value' ,'treemap_weight']
                ,aggfunc='sum'
                ).reset_index()
            # summary_rows['treemap_value'] = summary_rows['treemap_weighted_value'] / summary_rows['treemap_weight']
            treemap_df = pd.concat([treemap_df ,summary_rows] ,axis=0 ,ignore_index=True)

        # Add a row for the global total
        global_row = pd.DataFrame(dfmod[['treemap_weighted_value' ,'treemap_weight']].sum()).transpose()
        treemap_df = pd.concat([global_row ,treemap_df] ,axis=0 ,ignore_index=True)

        # Calculate weighted mean
        treemap_df['treemap_value'] = treemap_df['treemap_weighted_value'] / treemap_df['treemap_weight']

        # Drop rows with zero or negative value - these cause plotly to fail silently!
        treemap_df = treemap_df.query("treemap_value > 0")

        # Add columns for id and parent
        treemap_df['treemap_id'] = treemap_df[f'{HIERARCHY[0]}'].str.cat(treemap_df[HIERARCHY[1:]] ,sep='|' ,na_rep='_all_')
        treemap_df['treemap_id'] = treemap_df['treemap_id'].str.replace('|_all_' ,'' ,regex=False)
        treemap_df[['treemap_parent' ,'treemap_parent_remainder']] = treemap_df['treemap_id'].str.rsplit('|' ,n=1 ,expand=True)

        treemap_df.loc[treemap_df['treemap_parent_remainder'].isnull() ,'treemap_parent'] = '_all_'  # First level of hierarchy gets parent _all_
        treemap_df.loc[treemap_df['treemap_id'] == '_all_' ,'treemap_parent'] = ''  # Global level of hierarchy gets parent blank

        # Draw tree map
        # Figure is blank with no errors!!
        tree_map_fig = px.treemap(
            ids=treemap_df['treemap_id']
            ,parents=treemap_df['treemap_parent']
            ,values=treemap_df['treemap_value']
            ,color=treemap_df[COLOR_BY]
            )

        # Figure is blank with no errors!!
        # tree_map_fig = go.Figure(go.Treemap(
        #     ids=treemap_df['treemap_id']
        #     ,parents=treemap_df['treemap_parent']
        #     ,values=treemap_df['treemap_value']
        #     ))

    elif AGGREGATION == 'sum':
        tree_map_fig = px.treemap(
            INPUT_DF
            ,path=HIERARCHY
            ,values=VALUE_VAR
            ,color=COLOR_BY
            )

    return tree_map_fig

#%% 4. LAYOUT
##################################################################################################
# Here we layout the webpage, including dcc (Dash Core Component) controls we want to use, such as dropdowns.
##################################################################################################
gbadsDash.layout = html.Div([

    #### BRANDING & HEADING
    dbc.Row([
        # GBADs Branding
        dbc.Col(
            html.Div([
                html.A(href="https://animalhealthmetrics.org/",
                       target='_blank',
                       children=[
                       html.Img(title="Link to GBADS site", src=(os.environ.get("DASH_BASE_URL") if os.environ.get("DASH_BASE_URL") else "") + '/assets/GBADs-LOGO-Black-sm.png')
                       ]
                       ),
                html.H5("Inclusiveness Challenge Delivery Rigour Transparency",
                        style={"font-style": "italic",
                               "margin": "0",
                               "padding": "0"}),
                ], style = {'margin-left':"10px",
                            "margin-bottom":"10px",
                            'margin-right':"10px"},
                )
            ),
        ], justify='between'),

    #### TABS
    dcc.Tabs([ 
        
        #### LANDING PAGE
        dcc.Tab(label="Case Study Overview", children =[
            html.H3("Country Case Study: Animal Health Loss Envelope (AHLE)"),
            html.Label(["This interactive takes publicly available data along and consults with experts to create models that provide a country specific estimate of the animal health loss envelope."]),
        ### END OF LANDING PAGE TAB
        ], style=ecs_tab_style, selected_style=ecs_tab_selected_style),

        #### AHLE & ATTRIBUTION
        dcc.Tab(label="AHLE & Attribution", children =[

            html.H3("Ethiopia Animal Health Loss Envelope and Disease Attribution"),
            html.Label(["Displaying production values, expenditures, and gross margin under the current and ideal scenario estimated by a compartmental herd dynamics model. Attribution of AHLE to infectious, non-infectious, and external causes is based on the results of expert elicitation."]),
            # html.Label(["Results on this page are currently limited to cattle, small ruminants, and poultry, as those are the species for which the compartmental herd model has been estimated."]),
            html.Label(["Results on this page are currently limited to cattle, small ruminants, and poultry."]),
            html.Hr(style={'margin-right':'10px'}),
            html.Label(["Select a species and production system to view and the currency to display for all charts"]
                       ,style={"font-style":"italic"}
                       ),

            #### -- DROPDOWNS CONTROLS
            dbc.Row([
                dbc.Col([
                    html.H4("Species"),
                    dcc.Dropdown(id='select-species-ecs',
                                options=ecs_species_options,
                                value='Cattle',
                                clearable = False,
                                ),
                    ]),
                dbc.Col([
                    html.H4("Production System"),
                    dcc.Dropdown(id='select-prodsys-ecs',
                                 # Options and value are now defined in a callback based on selected species
                                 clearable = False,
                                 ),
                    ]),
                dbc.Col([
                    html.H4("Currency"),
                    dcc.Dropdown(id='select-currency-ecs',
                                options=ecs_currency_options,
                                value='Birr',
                                clearable = False,
                                ),
                    ]),
                
                # END OF FIRST CONTROL ROW
                ],style={"margin-bottom":"30px"}),  

            # SECOND CONTROL ROW
            dbc.Row([
                dbc.Col([
                    # Switch between single year and over time
                    html.H4("Display AHLE for..."),
                    dcc.RadioItems(id='select-graph-ahle-ecs',
                                  inline=True,                  # True: arrange buttons horizontally
                                  inputStyle={
                                      "margin-right":"2px",     # This pulls the words off of the button
                                      "margin-left":"10px",     # Space between buttons if inline=True
                                      },
                                  ),
                    # Text underneath
                    html.P("Estimates over time or for any year other than 2021 are currently placeholders" ,style={'font-style':'italic'}),
                    ]),

                # Year selector
                dbc.Col([
                    html.H5("Year"),
                    dcc.Dropdown(id='select-year-ecs',
                                 clearable = False,
                                 ),
                    ]),

                # Geographical breakdown options
                dbc.Col([
                    html.H4("AHLE Geographic Scope"),
                    dcc.RadioItems(id='select-geo-view-ecs',
                                  inline=True,                  # True: arrange buttons horizontally
                                  inputStyle={
                                      "margin-right":"2px",     # This pulls the words off of the button
                                      "margin-left":"10px",     # Space between buttons if inline=True
                                      },
                                  ),
                    # Text underneath
                    html.P("Subnational estimates are currently only available for cattle for 2021" ,style={'font-style':'italic'}),
                    ]),

                # Subnational dropdwon
                dbc.Col([
                    html.H5("Subnational state", id='select-region-ecs-title'),
                    dcc.Dropdown(id='select-region-ecs',
                                 options=ecs_region_options,
                                 placeholder='Select Subnational...',
                                 clearable = False,
                                 ),
                    ]),
                
                # END OF SECOND CONTROL ROW
                ],justify='evenly'),  

            html.Hr(style={'margin-right':'10px'}),

            dbc.Row([
                #### -- AHLE Specific Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Animal Health Loss Envelope (AHLE)",
                                    className="card-title",
                                    style={"font-weight": "bold"}
                                    ),
                            html.Label(["Comparing current values, expenditures, and gross margin to the ideal. Note that the ideal values and expenditures describe the system in an ideal state (for example, zero health expenditure); they do not describe what is required to achieve that state."]),
                            dbc.Row([
                                # Switch between side by side and difference
                                dbc.Col([
                                    html.H6("Show current and ideal as..."),
                                    dcc.RadioItems(id='select-display-ecs',
                                                   options=ecs_display_options,
                                                   value='Difference',
                                                   labelStyle={'display': 'block'},
                                                   inputStyle={"margin-right": "2px"}, # This pulls the words off of the button
                                                   ),
                                    html.Label(["Difference: show a single bar for each item representing the difference between the current and ideal values"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Side by Side: show two bars for each item, one for current and another for the ideal value"] ,style={'font-style':'italic'}),
                                    ]),

                                # Compare
                                dbc.Col([
                                    html.H6("Compare current to...", id='select-compare-ecs-title'),
                                    dcc.RadioItems(id='select-compare-ecs',
                                                   options=ecs_compare_options_limited,
                                                   value='Ideal',
                                                   labelStyle={'display': 'block'},
                                                   inputStyle={"margin-right": "2px"}, # This pulls the words off of the button
                                                   ),
                                    html.Label(["Ideal: zero mortality and ideal growth and production rates"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Zero Mortality: zero mortality but growth and production rates at current levels"] ,style={'font-style':'italic'}),
                                    ]),

                                # Age/Sex combination
                                dbc.Col([
                                    html.H6("Show results for group...", id='select-agesex-ecs-title'),
                                    dcc.Dropdown(id='select-agesex-ecs',
                                                 options=ecs_agesex_options,
                                                 value='Overall',
                                                 clearable = False,
                                                 ),
                                    html.Label(["Overall: show values and costs for whole system"] ,style={'font-style':'italic' ,"margin-top":"20px"}),
                                    html.Label(["Otherwise, show values and costs for just the selected age/sex group"] ,style={'font-style':'italic'}),
                                    ]),
                            ]), # END OF ROW
                            dbc.Row([
                                dbc.Col([
                                    html.H6("Item", id='select-item-ecs-title'),
                                    dcc.Dropdown(id='select-item-ecs',
                                                 value='Gross Margin',
                                                 clearable = False,
                                                 ),
                                    ]),

                                # Factor dropdown
                                dbc.Col([
                                    html.H6("Improvement Factor", id='select-factor-ecs-title'),
                                    dcc.Dropdown(id='select-factor-ecs',
                                                  options=ecs_factor_options,
                                                  value='Mortality',
                                                  clearable = True,
                                                  ),
                                      ],width=4,
                                    ),

                                # Reduction
                                dbc.Col([
                                    html.H6("Improvement Amount", id='select-improve-ecs-title'),
                                    dcc.RadioItems(id='select-improve-ecs',
                                                  options=ecs_improve_options,
                                                  value= "25%",
                                                  inputStyle={"margin-right": "2px", # This pulls the words off of the button
                                                              "margin-left": "10px"},
                                                  ),
                                    ]),
                                ]),     ## END OF ROW ##
                            ]),    # END OF CARD BODY
                        ], color='#F2F2F2'),    # END OF CARD
                    ],width=6),

                #### -- Attribution Specific Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("AHLE Attribution",
                                    className="card-title",
                                    style={"font-weight": "bold"}),
                            html.Label(["Showing how each component contributes to the total animal health loss envelope, including attribution to infectious, non-infectious, and external causes."]),
                            html.Label(["NOTE: this is shown for species groups (cattle, all small ruminants, or all poultry) rather than for individual species."] ,style={"font-style":"italic"}),
                            html.H5("Segment by..."),
                            dbc.Row([
                                # Top Level
                                dbc.Col([
                                    html.H6("Top Level", id="select-top-lvl-attr-ecs-title"),
                                    dcc.Dropdown(id='select-top-lvl-attr-ecs',
                                                  options=ecs_hierarchy_attr_options,
                                                  value='cause',
                                                  clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                # Drilldown 1
                                dbc.Col([
                                    html.H6("Drilldown 1", id="select-dd-1-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-1-attr-ecs',
                                                  # options=ecs_hierarchy_dd_attr_options,
                                                  # value='production_system',
                                                   clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                # Drilldown 2
                                dbc.Col([
                                    html.H6("Drilldown 2", id="select-dd-2-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-2-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='age_group',
                                                  clearable = False,
                                                  ),
                                    ], style={
                                        "margin-bottom":"30px", # Adding this to account for the additional space created by the radio buttons
                                        },
                                    ),
                                ]), # END OF ROW
                            dbc.Row([
                                # Drilldown 3
                                dbc.Col([
                                    html.H6("Drilldown 3", id="select-dd-3-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-3-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='disease',
                                                  clearable = False,
                                                  ),
                                    ]),
                                # Drilldown 4
                                dbc.Col([
                                    html.H6("Drilldown 4", id="select-dd-4-attr-ecs-title"),
                                    dcc.Dropdown(id='select-dd-4-attr-ecs',
                                                  options=ecs_hierarchy_dd_attr_options,
                                                  value='ahle_component',
                                                  clearable = False,
                                                  ),
                                    ]),
                                ]), # END OF ROW
                            html.Label([
                                "Disease drilldown shows infectious AHLE broken out as follows depending on species:"
                                ,html.Br()
                                ,"- Cattle: Brucellosis | FMD | Other Infectious"
                                ,html.Br()
                                ,"- Small ruminants: Brucellosis | PPR | Other Infectious"
                                ,html.Br()
                                ,html.Br()
                                ,"Set any drill down to None to segment by fewer factors"
                                ] ,style={"font-style":"italic" ,"margin-top":"10px"}
                                ),
                            # html.Label(["Set any drill down to None to segment by fewer factors"] ,style={"font-style":"italic"}),
                            ]),     # END OF CARD BODY
                        ], color='#F2F2F2'),    # END OF CARD
                    ]),
                ], justify='evenly'),   # END OF DROPDOWN CONTROLS
            html.Br(),

            #### -- GRAPHICS PT.1
            dbc.Row([  # Row with GRAPHICS

                # Values and Costs Waterfall
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-ahle-waterfall',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_AHLE_Sunburst'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                              'zoomIn',
                                                              'zoomOut',
                                                              'autoScale',
                                                              #'resetScale',  # Removes home button
                                                              'pan',
                                                              'select2d',
                                                              'lasso2d']
                                  }
                              )
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of AHLE Sunburst
                    ],style={"width":5}),

                # Attribution Treemap
                dbc.Col(
                    dbc.Spinner(children=[

                    dcc.Graph(id='ecs-attr-treemap',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              )
                    # End of Spinner
                    ],size="md", color="#393375", fullscreen=False),
                    # End of Attribution Treemap
                    style={"width":5}),
                ]),

            #### -- FOOTNOTES PT.1
            dbc.Row([
                dbc.Col([   # Waterfall footnote
                    html.P("Blue indicates an increase, red indicates a decrease for each item. Orange is the net value of all of them.", id="waterfall-footnote-ecs"),
                    html.P("Error bars show 95% confidence interval for each item based on simulation results and reflect uncertainty in the input parameters"),
                ]),
                dbc.Col([   # Treemap footnote
                    html.P("Attribution to infectious, non-infectious, and external causes is based on expert opinion. See the expert opinion attribution proportions in the table below."),
                    html.P("AHLE Components are production loss, mortality loss, and health cost. Health cost makes up the smallest proportion and may not be visible in this view."),
                ]),
            ], style={'font-style': 'italic'}
            ),
            ### END OF FOOTNOTES

            html.Hr(style={'margin-right':'10px',}),

            #### -- MAP
            dbc.Card([
                dbc.CardBody([
                    html.H3("Subnational AHLE"),
                    html.Label(["Showing the animal health loss envelope for each subnational state. Use the dropdown to view an individual item of revenue, expenditure, or gross margin instead."]),
                    html.Label(["Note: a subnational state will appear blank if there is no data for the selected production system there"] ,style={"font-style":"italic"}),
                    dbc.Row([
                        # Map Display
                        dbc.Col([
                            html.H5("Item"),
                            dcc.Dropdown(id='select-map-display-ecs',
                                         value='Animal Health Loss Envelope',
                                         clearable=False,
                                         ),
                            ],width=3),

                        # Denominator
                        dbc.Col([
                            html.H5("Show values as..."),
                            dcc.RadioItems(id='select-map-denominator-ecs',
                                          options=ecs_map_denominator_options,
                                          value= "Per kg biomass",
                                          inputStyle={"margin-right": "2px", # This pulls the words off of the button
                                                      "margin-left": "10px"},
                                          ),
                            ]),
                        ]), # END OF MAP SELECTIONS ROW
                    ]),     # END OF CARD BODY
                ], color='#F2F2F2', style={"margin-right": "10px"}),    # END OF CARD

            # Map viz
            dbc.Row([
                dbc.Col([ # Ethiopian subnational level
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-map',
                                style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Subnational_Viz'
                                      },
                                  }
                              )
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),     # End of Map
                ]),     # END OF MAP ROW

            #### -- MAP FOOTNOTES
            dbc.Row([
                html.P("Livestock data is not shown for city regions (Addis Ababa, Dire Dawa, and Harari)"),
                html.P("South West Ethiopia did not have data available at the time of analysis. It is showing the same values as SNNP."),
                ], style={'font-style': 'italic'}
                ),

            #### -- GRAPHICS PT.2
            # dbc.Row([
            #     dbc.Col([ # AHLE Stacked Bar
            #         dbc.Spinner(children=[
            #         dcc.Graph(id='ahle-stacked-bar-ecs',
            #                   style = {"height":"500px"},
            #                   config = {
            #                       "displayModeBar" : True,
            #                       "displaylogo": False,
            #                       'toImageButtonOptions': {
            #                           'format': 'png', # one of png, svg, jpeg, webp
            #                           'filename': 'GBADs_AHLE_Stacked_Bar_ECS'
            #                           },
            #                       'modeBarButtonsToRemove': ['zoom',
            #                                                   'zoomIn',
            #                                                   'zoomOut',
            #                                                   'autoScale',
            #                                                   #'resetScale',  # Removes home button
            #                                                   'pan',
            #                                                   'select2d',
            #                                                   'lasso2d']
            #                       }
            #                   )
            #             ],size="md", color="#393375", fullscreen=False),    # End of Spinner
            #         ],style={"width":5}     # End of Stacked Bar
            #         ),

            #     # Sankey
            #     dbc.Col([
            #     dbc.Spinner(children=[
            #         html.H4("Sankey for Attribution"),
            #             html.Div(children=[
            #                     html.Img(src=(os.environ.get("DASH_BASE_URL") if os.environ.get("DASH_BASE_URL") else "") + '/assets/ECS_Sanky_diagram_from_Gemma.png',
            #                     style = {'width':'120vw'}),
            #                     ],
            #                       style = {
            #                               "margin-bottom":"10px",
            #                               'margin-right':"10px",},
            #                       ),
            #             # End of Spinner
            #             ],size="md", color="#393375", fullscreen=False),
            #         ]),
            #     ]), # END OF ROW

            #### -- FOOTNOTES PT.2
            # dbc.Row([
            #     dbc.Col([
            #         # Stacked bar
            #         html.P("Expenditure on Health is not recorded for individual age groups so is not included in individual AHLE calculations."),
            #         html.P("Expenditure on Health is very small, so the impact on AHLE is negligible."),
            #         ]),
            #     dbc.Col([
            #         # Sankey
            #         # No footnote
            #         ]),
            #     ], style={'font-style': 'italic'}
            #     ),

            html.Hr(style={'margin-right':'10px',}),
            
            ### END OF AHLE & ATTRIBUTION TAB
            ], style=ecs_tab_style, selected_style=ecs_tab_selected_style),     

                                        
        #### WEI
        dcc.Tab(label="Wider Economic Impact", children =[     
            dbc.Row([
                html.H3("Wider Economic Impact"),
                html.Label(["Estimating the total economic impact of each scenario for cattle and small ruminants using the ",
                            html.A('GTAP model.', href='https://www.gtap.agecon.purdue.edu/' ,target='_blank')  # target='_blank' to open in a new tab
                            ]),
            #### -- GRAPHICS
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-wei-chart-1',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              ),
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),
                dbc.Col([
                    dbc.Spinner(children=[
                    dcc.Graph(id='ecs-wei-chart-2',
                              style = {"height":"650px"},
                              config = {
                                  "displayModeBar" : True,
                                  "displaylogo": False,
                                  'toImageButtonOptions': {
                                      'format': 'png', # one of png, svg, jpeg, webp
                                      'filename': 'GBADs_Ethiopia_Attribution_Treemap'
                                      },
                                  'modeBarButtonsToRemove': ['zoom',
                                                             'zoomIn',
                                                             'zoomOut',
                                                             'autoScale',
                                                             #'resetScale',  # Removes home button
                                                             'pan',
                                                             'select2d',
                                                             'lasso2d']
                                  }
                              ),
                        ],size="md", color="#393375", fullscreen=False),    # End of Spinner
                    ]),
            
            ### END OF GRAPHICS
                ]),

            #### -- FOOTNOTES
            dbc.Row([
                dbc.Col([   # Chart 1 footnote
                    html.P("% Change in Production is the % change in live animal production."),
                ]),
                dbc.Col([   # Chart 2 footnote
                    html.P("Economic surplus refers to the monetary gains that a consumer or producer or both accrues from an economic activity."),
                ]),
            ], style={'font-style': 'italic'}
            ),
            ### END OF FOOTNOTES

        ### END OF WEI TAB
        ], style=ecs_tab_style, selected_style=ecs_tab_selected_style),  


        #### DATATABLES 
        dcc.Tab(label="Data Viewer", children =[ 
            html.H3("Data Viewer", id="ETH-data-export"),
            #### -- DATATABLES
            dbc.Row([
                dbc.Col([
                    html.Div([  # Core data for AHLE
                          html.Div( id='ecs-ahle-datatable'),
                          ], style={'margin-left':"20px"}),
                    html.Br() # Spacer for bottom of page
                    ]),
                dbc.Col([
                    html.Div([  # Core data for attribution
                          html.Div( id='ecs-attr-datatable'),
                          ], style={'margin-left':"20px",}),
                    html.Br(),
                    html.Div([  # Attribution expert opinion
                          html.Div( id='ecs-attr-expert-opinion'),
                          ], style={'margin-left':"20px",}),
                    html.Br(), # Spacer for bottom of page
                    ]),  # END OF COL
                ]),     # END OF ROW
        html.Br(),
        
        ### END OF DATATABLES
        ], style=ecs_tab_style, selected_style=ecs_tab_selected_style),  
                                        
        #### USER GUIDE TAB
        dcc.Tab(label="User Guide & References", children =[
            html.Iframe(src="assets/GBADs_Documentation/_build/html/index.html", # this is for the jupyter books
                        style={"width":"100%",
                                "height":"3600px",   # Set large enough for your largest page and guide will use browser scroll bar. Otherwise, longer pages will get their own scroll bars.
                                },)
        ### END OF USER GUIDE TAB
            ], style=user_guide_tab_style, selected_style=user_guide_tab_selected_style),
                                        
                                        
        ### END OF TABS ###
        ],style={'margin-right':'10px',
                 'margin-left': '10px'}, )

        ])



#%% 5. CALLBACKS
# This section does the interactivity work with the web page
# - Listens to Inputs, linked to the id's of various web page elements in the LAYOUT
# - Changes the webpage with Outputs, also linked to the id's in the LAYOUT

# Version using multiple callbacks relies on passing data between them
# See https://dash.plotly.com/sharing-data-between-callbacks
# ==============================================================================
#### UPDATE ETHIOPIA
# ==============================================================================
# ------------------------------------------------------------------------------
#### -- Controls
# ------------------------------------------------------------------------------
# Update production system options based on species
@gbadsDash.callback(
    Output('select-prodsys-ecs', 'options'),
    Output('select-prodsys-ecs', 'value'),
    Input('select-species-ecs', 'value'),
    )
def update_prodsys_options_ecs(species):
    # Get unique production systems for selected species
    unique_prodsys = np.sort(ecs_ahle_summary.loc[ecs_ahle_summary['species'] == species ,'production_system'].unique())
    options = [{'label': i, 'value': i} for i in unique_prodsys]
    value = options[0]['value']  # Default is first one
    return options, value

# Longitudinal options
@gbadsDash.callback(
    Output('select-graph-ahle-ecs','options'),
    Output('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_longitudinal_options_ecs(species):
    options = [
        {'label': "Single Year", 'value': "Single Year", 'disabled': False},
        {'label': "Over Time", 'value': "Over Time", 'disabled': False}
        ]
    value='Single Year'

    # Disable option if species doesn't support it
    # if species.upper() != 'CATTLE':
    #     for d in options:
    #         d['disabled']=True
    return options, value

# Year selector
@gbadsDash.callback(
    Output('select-year-ecs','options'),
    Output('select-year-ecs','value'),
    Output('select-year-ecs','placeholder'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_year_select_ecs(graph, species):
    value=2021
    ecs_year_options=[]     # By default, list is blank
    placeholder = '2021'

    if graph == 'Over Time':   # Over time placeholder is (all)
        placeholder = '(all)'
    # Other years only available for Cattle
    # elif (graph == 'Single Year') & (species.upper() == 'CATTLE'):
    #     ecs_year_options=[]
    #     for i in np.sort(ecs_ahle_summary['year'].unique()):
    #         str(ecs_year_options.append({'label':i,'value':(i)}))
    # Have placeholder values for all species and years
    elif graph == 'Single Year':
        ecs_year_options=[]
        for i in np.sort(ecs_ahle_summary['year'].unique()):
            str(ecs_year_options.append({'label':i,'value':(i)}))
    else:
        None

    return ecs_year_options, value, placeholder

# Geographical options
@gbadsDash.callback(
    Output('select-geo-view-ecs','options'),
    Output('select-geo-view-ecs','value'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-year-ecs', 'value'),
    )
def update_geo_view_options_ecs(graph, species, year):
    options = [
        {'label': "National", 'value': "National", 'disabled': False},
        {'label': "Subnational", 'value': "Subnational", 'disabled': True}  # Update Aug 2023: disabling subnational views as these scenarios are incomplete and cause missing values in attribution
        ]
    value='National'

    # Disable controls if Over Time selected
    if graph.upper() == 'OVER TIME':
        for d in options:
            d['disabled']=True

    # Disable if any year outside 2021 is selected
    if year != 2021:
        for d in options:
            d['disabled']=True

    # Disable if any species other than cattle is selected
    if species.upper() != 'CATTLE':
        for d in options:
            d['disabled']=True
    return options, value

# Update agesex group options based on species
@gbadsDash.callback(
    Output('select-agesex-ecs', 'options'),
    Input('select-species-ecs', 'value'),
    )
def update_age_options_ecs(species):
    if species == "Cattle":
        options = ecs_agesex_options
    else:
        options = ecs_agesex_options.copy()
        for d in options:
            if d['value'] == 'Oxen':
                options.remove(d)
    return options

# Remove improvement option from scenario for cattle and poultry while those are misssing
# August 2023: updated scenarios do not include zero mortality or improvement
# @gbadsDash.callback(
#     Output('select-compare-ecs', 'options'),
#     Input('select-species-ecs', 'value'),
#     )
# def update_compare_options_ecs(species):
#     if species == "Cattle" or species == 'All Poultry' or species == 'Poultry hybrid' or species == 'Poultry indigenous':
#         options = ecs_compare_options.copy()
#         for d in options:
#             if d['value'] == 'Improvement':
#                 options.remove(d)
#     else:
#         options = ecs_compare_options
#     return options

# Update hierarchy dropdown filters to remove higher level selections from the options
# And change if displaying stacked bar
@gbadsDash.callback(
    Output('select-top-lvl-attr-ecs-title','children'),
    Input('select-graph-ahle-ecs','value'),
    )
def update_year_item_switch(graph):
    if graph == 'Single Year':
        title = 'Top Level'
    else:
        title = 'Segmentation'
    return title

@gbadsDash.callback(
    Output('select-dd-1-attr-ecs','options'),
    Output('select-dd-1-attr-ecs','value'),
    Output('select-dd-1-attr-ecs','style'),
    Output('select-dd-1-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    )
def update_dd1_options_ecs(graph, top_lvl_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] == top_lvl_hierarchy:
                d['disabled']=True
            else:
                d['disabled']=False
        display_style = {'display': 'block'}

    value='production_system'

    return options, value, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-2-attr-ecs','options'),
    Output('select-dd-2-attr-ecs','style'),
    Output('select-dd-2-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    )
def update_dd2_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-3-attr-ecs','options'),
    Output('select-dd-3-attr-ecs','style'),
    Output('select-dd-3-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    )
def update_dd3_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy):
    options = ecs_hierarchy_dd_attr_options

    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

@gbadsDash.callback(
    Output('select-dd-4-attr-ecs','options'),
    Output('select-dd-4-attr-ecs','style'),
    Output('select-dd-4-attr-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    Input('select-dd-3-attr-ecs','value'),
    )
def update_dd4_options_ecs(graph, top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy, dd3_hierarchy):
    options = ecs_hierarchy_dd_attr_options
    if graph == 'Over Time':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    else:
        for d in options:
            if d['value'] != 'None':
                if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy or d['value'] == dd3_hierarchy:
                    d['disabled']= True
                else:
                    d['disabled']=False
        display_style = {'display': 'block'}

    return options, display_style, display_style

# @gbadsDash.callback(
#     Output('select-dd-5-attr-ecs','options'),
#     Input('select-top-lvl-attr-ecs','value'),
#     Input('select-dd-1-attr-ecs','value'),
#     Input('select-dd-2-attr-ecs','value'),
#     Input('select-dd-3-attr-ecs','value'),
#     Input('select-dd-4-attr-ecs','value'),
#     )
# def update_dd5_options_ecs(top_lvl_hierarchy, dd1_hierarchy, dd2_hierarchy, dd3_hierarchy, dd4_hierarchy):
#     options = ecs_hierarchy_dd_attr_options
#     for d in options:
#         if d['value'] != 'None':
#             if d['value'] == top_lvl_hierarchy or d['value'] == dd1_hierarchy or d['value'] == dd2_hierarchy or d['value'] == dd3_hierarchy or d['value'] == dd4_hierarchy:
#                 d['disabled']= True
#             else:
#                 d['disabled']=False
#     return options

@gbadsDash.callback(
    Output('select-region-ecs','style'),
    Output('select-region-ecs-title','style'),
    Output('select-region-ecs','value'),
    Output('select-region-ecs','options'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-geo-view-ecs','value'),
    )
def update_ahle_graph_controls(graph, geo_view):
    options2 = ecs_region_options.copy()

    for d in options2:
        if graph == 'Over Time':
            block = {'display': 'none'} # hide
            value = ''
            d['disabled']=True

        else:
            block = {'display': 'block'}
            if geo_view == 'National':
                value = ''
                d['disabled']=True
            else:
                value='Afar'
                d['disabled']=False

    return block, block, value, options2

# Show Item select when display is over time
@gbadsDash.callback(
    Output('select-item-ecs','options'),
    Output('select-item-ecs','style'),
    Output('select-item-ecs-title','style'),
    Input('select-graph-ahle-ecs','value'),
    Input('select-species-ecs','value'),
    )
def update_item_dropdown_ecs(graph, species):
    # Filters Items to display based on species selected
    if species == "Cattle":     # Cattle have draught
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Draught',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Eggs consumed',
                        'Value of Eggs sold',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    else:
        item_options = ('Gross Margin',
                        'Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        'Expenditure on Feed',
                        'Expenditure on Labour',
                        'Expenditure on Health',
                        # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                        # 'Expenditure on Housing',
                        # 'Expenditure on Capital',
                        )
    # Build dictionary
    options=[]
    for i in item_options:
        str(options.append({'label':i,'value':(i)}))
    display_style = {'display': 'block'}

    # Hide controls if Single Year selected
    if graph == 'Single Year':
        for d in options:
            d['disabled']=True
        display_style = {'display': 'none'}

    return options, display_style, display_style

# Enable the options for factor/improvement when 'Improvement' selected
@gbadsDash.callback(
    Output('select-factor-ecs','options'),
    Output('select-factor-ecs','style'),
    Output('select-factor-ecs-title','style'),
    Output('select-improve-ecs','options'),
    Output('select-improve-ecs','style'),
    Output('select-improve-ecs-title','style'),
    Input('select-compare-ecs','value'),
    )
def update_improvment_factors(compare):
    options1 = ecs_factor_options.copy()
    options2 = ecs_improve_options.copy()
    for d in options1:
        if compare == 'Improvement':
            block = {'display': 'block'}
            if d['value'] != 'Lactation':
                d['disabled']=False
        else:
            block = {'display': 'none'} # hide the improvement options
            d['disabled']=True
    for d in options2:
        if compare == 'Improvement':
            block = {'display': 'block'}
            d['disabled']=False
        else:
            block = {'display': 'none'} # hide the improvement options
            d['disabled']=True

    return options1, block, block, options2, block, block

# Display Item values for map display based on selections
@gbadsDash.callback(
    Output('select-map-display-ecs','options'),
    Input('select-species-ecs','value'),
    )
def update_map_display_options_ecs(species):
    # Filters Items to display based on species selected
    if 'CATTLE' in species.upper():    # Cattle have draught
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of draught',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        )
    elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Eggs consumed',
                        'Value of Eggs sold',
                        )
    else:
        item_options = ('Value of Offtake',
                        'Value of Herd Increase',
                        'Value of Milk',
                        'Value of Manure',
                        'Value of Hides',
                        )
    # Build dictionary
    options=[]

    # Add options for AHLE and gross margin
    options += [{'label': i, 'value': i, 'disabled': False} for i in [
        "Animal Health Loss Envelope",
        "Ideal Gross Margin",
        ]]
    options += [{'label':"Current Gross Margin", 'value':"Gross Margin"}]

    # Add options for values using species-specific list from above
    for i in item_options:
        str(options.append({'label':'Current ' + i,'value':(i)}))

    # Add Expenditure values
    options += [{'label':"Current Expenditure on Feed", 'value':"Feed Cost"},
                {'label':"Current Expenditure on Labour", 'value':"Labour Cost"},
                {'label':"Current Expenditure on Health", 'value':"Health Cost"},
                # May 2023: Wudu does not want housing and captial expenses in waterfall chart or map
                # {'label':"Current Expenditure on Housing", 'value':"Infrastructure Cost"},
                # {'label':"Current Expenditure on Capital", 'value':"Capital Cost"},
                ]

    return options

# Hide waterfall specific footnote when waterfall is not showing
@gbadsDash.callback(
    Output('waterfall-footnote-ecs','style'),
    Input('select-graph-ahle-ecs','value'),
    )
def update_footnote(graph):
    if graph.upper() == 'SINGLE YEAR':
        block = {'display': 'block'}
    else:
        block = {'display': 'none'} # hide

    return block

# ------------------------------------------------------------------------------
#### -- Data
# ------------------------------------------------------------------------------
# AHLE datatable below graphic
@gbadsDash.callback(
    Output('ecs-ahle-datatable', 'children'),
    Input('select-currency-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-agesex-ecs', 'value'),
)
def update_ecs_ahle_data(currency, species, prodsys, agesex):
    # Read in data and apply filters
    input_df = ecs_ahle_summary.copy()

    # Species filter
    input_df = input_df.loc[(input_df['species'] == species)]

    # Production System filter
    # Rename values to match filters
    input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})
    input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Age/sex filter
    input_df=input_df.loc[(input_df['group'] == agesex)]

    # If currency is USD, use USD columns
    display_currency = 'Birr'
    if currency == 'USD':
        display_currency = 'USD'

        input_df['mean_current'] = input_df['mean_current_usd']
        input_df['stdev_current'] = input_df['stdev_current_usd']
        # input_df['mean_mortality_zero'] = input_df['mean_mortality_zero_usd']
        # input_df['stdev_mortality_zero'] = input_df['stdev_mortality_zero_usd']
        input_df['mean_ideal'] = input_df['mean_ideal_usd']
        input_df['stdev_ideal'] = input_df['stdev_ideal_usd']

    # Format numbers
    input_df.update(input_df[['mean_current',
                              'mean_ideal',
                              # 'mean_mortality_zero',
                              'mean_diff_ideal',
                              # 'mean_diff_mortzero',
                              ]].applymap('{:,.0f}'.format))

    columns_to_display_with_labels = {
        'species':'Species'
        ,'production_system':'Production System'
        ,'region':'Region'
        ,'year':'Year'
        ,'item':'Value or Cost'
        ,'group':'Group'
        ,'mean_current':f'Current Mean ({display_currency})'
        ,'mean_ideal':f'Ideal Mean ({display_currency})'
        # ,'mean_mortality_zero':f'Mortality Zero Mean ({display_currency})'
        ,'mean_diff_ideal':'AHLE (Ideal - Current)'
        # ,'mean_diff_mortzero':'AHLE due to Mortality (Mortality Zero - Current)'
    }

    # Subset columns
    input_df = input_df[list(columns_to_display_with_labels)]

    # Keep only items for the waterfall
    waterfall_plot_items = ('Value of Offtake',
                             'Value of Herd Increase',
                             'Value of draught',
                             'Value of Milk',
                             'Value of Eggs consumed',
                             'Value of Eggs sold',
                             'Value of Manure',
                             'Value of Hides',
                             'Feed Cost',
                             'Labour Cost',
                             'Health Cost',
                             'Capital Cost',
                             'Gross Margin')
    waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
    input_df = input_df.loc[input_df['item'].str.upper().isin(waterfall_plot_items_upper)]


    return [
            dcc.Markdown(
                '''
                #### AHLE Data

                Showing the major production and cost values under current and ideal scenarios

                *Output of the compartmental population model*
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                             'height': '785px',},
            )
        ]

# Attribution datatable below graphic
@gbadsDash.callback(
    Output('ecs-attr-datatable', 'children'),
    Input('select-currency-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-year-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
    )
def update_ecs_attr_data(currency, prodsys, species, year, geo_view, region):
    # Read in data
    input_df = ecs_ahle_all_withattr

    # Production System filter
    # If All production systems, don't filter. Attribution data is not aggregated to that level.
    if prodsys == 'All Production Systems':
        input_df=input_df
    else:
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Species filter
    # Goat and Sheep do not appear separately. These get all small ruminants results.
    if species == 'Goat' or species == "Sheep":
        input_df=input_df.loc[(input_df['species'] == 'All Small Ruminants')]
    # Poultry subspecies do not appear separately. These get all poultry results.
    elif species == 'Poultry hybrid' or species == "Poultry indigenous":
        input_df=input_df.loc[(input_df['species'] == 'All Poultry')]
    else:
        input_df=input_df.loc[(input_df['species'] == species)]

    # Year filter
    input_df=input_df.loc[(input_df['year'] == year)]

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
    else:
        input_df = input_df.query("region == @region")

    # If currency is USD, use USD columns
    display_currency = 'Birr'
    if currency == 'USD':
        display_currency = 'USD'

    # Format numbers
    input_df.update(input_df[['mean',
                              'sd',
                              'lower95',
                              'upper95',
                              ]].applymap('{:,.0f}'.format))
    # input_df.update(input_df[['pct_of_total']].applymap('{:,.2f}%'.format))

    columns_to_display_with_labels = {
        'species':'Species'
        ,'production_system':'Production System'
        ,'region':'Region'
        ,'age_group':'Age'
        ,'sex':'Sex'
        ,'year':'Year'
        ,'ahle_component':'AHLE Component'
        ,'cause':'Attribution'
        ,'disease':'Disease'
        ,'mean':f'Mean ({display_currency})'
        ,'sd':'Std. Dev.'
        ,'lower95':'Lower 95%'
        ,'upper95':'Upper 95%'
        # ,'pct_of_total':'Percent of Total AHLE'
    }

    # Subset columns
    input_df = input_df[list(columns_to_display_with_labels)]

    return [
            dcc.Markdown(
                '''
                #### Attribution Data

                Attributing the AHLE components to infectious, non-infectious, and external causes

                *Based on expert opinion attribution proportions*
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '320px',
                              'overflowY': 'auto'},
                page_action='none',
            )
        ]

# Attribution expert opinion
@gbadsDash.callback(
    Output('ecs-attr-expert-opinion', 'children'),
    Input('select-species-ecs','value'),
    )
def update_ecs_attr_expert_data(species):
    # Read in data depending on species selected
    if species in ["All Small Ruminants", "Goat", "Sheep"]:
        input_df = ecs_expertattr_smallrum
        spec_label = "Small Ruminants"
    elif species == "Cattle":
        input_df = ecs_expertattr_cattle
        spec_label = "Cattle"
    elif species in ["All Poultry", "Poultry hybrid", "Poultry indigenous"]:
        input_df = ecs_expertattr_poultry
        spec_label = "Poultry"

    # Format numbers
    for COL in ['min' ,'avg' ,'max']:
        input_df[COL] = pd.to_numeric(input_df[COL] ,errors='coerce')  # Ensure numeric
    input_df[['min' ,'avg' ,'max']] = input_df[['min' ,'avg' ,'max']] / 100     # Convert to proportions
    input_df.update(input_df[['min', 'avg', 'max']].applymap('{:.0%}'.format))

    columns_to_display_with_labels = {
        'Expert':'Expert'
        ,'AHLE':'AHLE Component'
        ,'Production system':'Production system'
        ,'Age class':'Age class'
        ,'Cause':'Cause'
        ,'min':'Minimum'
        ,'avg':'Average'
        ,'max':'Max'
        }
    return [
            dcc.Markdown(
                f'''
                #### Expert Opinion Attribution Proportions

                {spec_label}
                '''
                ),
            dash_table.DataTable(
                columns=[{"name": j, "id": i} for i, j in columns_to_display_with_labels.items()],
                data=input_df.to_dict('records'),
                export_format="csv",
                style_cell={
                    # 'minWidth': '250px',
                    'font-family':'sans-serif',
                    },
                style_table={'overflowX': 'scroll',
                              'height': '320px',
                              'overflowY': 'auto'},
                page_action='none',
            )
        ]

# ------------------------------------------------------------------------------
#### -- Figures
# ------------------------------------------------------------------------------
# AHLE Waterfall or Longitudinal Graph
@gbadsDash.callback(
    Output('ecs-ahle-waterfall','figure'),
    Input('select-graph-ahle-ecs', 'value'),
    Input('select-agesex-ecs', 'value'),
    Input('select-species-ecs','value'),
    Input('select-display-ecs','value'),
    Input('select-compare-ecs','value'),
    Input('select-prodsys-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-factor-ecs','value'),
    Input('select-improve-ecs','value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
    )
def update_ahle_value_and_cost_viz_ecs(
        graph_options,
        agesex,
        species,
        display,
        compare,
        prodsys,
        currency,
        impvmnt_factor,
        impvmnt_value,
        selected_year,
        selected_item,
        geo_view,
        region,
    ):
    # Read in data and apply filters
    input_df = ecs_ahle_summary

    # Species filter
    input_df = input_df.loc[(input_df['species'] == species)]

    # Production System filter
    input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Age/sex filter
    input_df=input_df.loc[(input_df['group'] == agesex)]

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
        reg_title = 'National'
    else:
        input_df = input_df.query("region == @region")
        reg_title = region

    # Prep the data
    prep_df = prep_ahle_forwaterfall_ecs(input_df)

    # If currency is USD, use USD columns
    display_currency = 'Ethiopian Birr'
    if currency == 'USD':
        display_currency = 'USD'

        prep_df['mean_current']                     = prep_df['mean_current_usd']
        # prep_df['mean_mortality_zero']              = prep_df['mean_mortality_zero_usd']
        prep_df['mean_ideal']                       = prep_df['mean_ideal_usd']
        prep_df['mean_diff_ideal']                  = prep_df['mean_diff_ideal_usd']
        # prep_df['mean_diff_mortzero']               = prep_df['mean_diff_mortzero_usd']
        # prep_df['mean_all_mort_25_imp']             = prep_df['mean_all_mort_25_imp_usd']
        # prep_df['mean_all_mort_50_imp']             = prep_df['mean_all_mort_50_imp_usd']
        # prep_df['mean_all_mort_75_imp']             = prep_df['mean_all_mort_75_imp_usd']
        # prep_df['mean_diff_mortimp25']              = prep_df['mean_diff_mortimp25_usd']
        # prep_df['mean_diff_mortimp50']              = prep_df['mean_diff_mortimp50_usd']
        # prep_df['mean_diff_mortimp75']              = prep_df['mean_diff_mortimp75_usd']
        # prep_df['mean_current_repro_25_imp']        = prep_df['mean_current_repro_25_imp_usd']
        # prep_df['mean_current_repro_50_imp']        = prep_df['mean_current_repro_50_imp_usd']
        # prep_df['mean_current_repro_75_imp']        = prep_df['mean_current_repro_75_imp_usd']
        # prep_df['mean_current_repro_100_imp']       = prep_df['mean_current_repro_100_imp_usd']
        # prep_df['mean_diff_reprimp25']              = prep_df['mean_diff_reprimp25_usd']
        # prep_df['mean_diff_reprimp50']              = prep_df['mean_diff_reprimp50_usd']
        # prep_df['mean_diff_reprimp75']              = prep_df['mean_diff_reprimp75_usd']
        # prep_df['mean_diff_reprimp100']             = prep_df['mean_diff_reprimp100_usd']
        # prep_df['mean_current_growth_25_imp_all']   = prep_df['mean_current_growth_25_imp_all_usd']
        # prep_df['mean_current_growth_50_imp_all']   = prep_df['mean_current_growth_50_imp_all_usd']
        # prep_df['mean_current_growth_75_imp_all']   = prep_df['mean_current_growth_75_imp_all_usd']
        # prep_df['mean_current_growth_100_imp_all']  = prep_df['mean_current_growth_100_imp_all_usd']
        # prep_df['mean_diff_growimp25']              = prep_df['mean_diff_growimp25_usd']
        # prep_df['mean_diff_growimp50']              = prep_df['mean_diff_growimp50_usd']
        # prep_df['mean_diff_growimp75']              = prep_df['mean_diff_growimp75_usd']
        # prep_df['mean_diff_growimp100']             = prep_df['mean_diff_growimp100_usd']

        prep_df['stdev_current']                     = prep_df['stdev_current_usd']
        # prep_df['stdev_mortality_zero']              = prep_df['stdev_mortality_zero_usd']
        prep_df['stdev_ideal']                       = prep_df['stdev_ideal_usd']
        prep_df['stdev_diff_ideal']                  = prep_df['stdev_diff_ideal_usd']
        # prep_df['stdev_diff_mortzero']               = prep_df['stdev_diff_mortzero_usd']
        # prep_df['stdev_all_mort_25_imp']             = prep_df['stdev_all_mort_25_imp_usd']
        # prep_df['stdev_all_mort_50_imp']             = prep_df['stdev_all_mort_50_imp_usd']
        # prep_df['stdev_all_mort_75_imp']             = prep_df['stdev_all_mort_75_imp_usd']
        # prep_df['stdev_diff_mortimp25']              = prep_df['stdev_diff_mortimp25_usd']
        # prep_df['stdev_diff_mortimp50']              = prep_df['stdev_diff_mortimp50_usd']
        # prep_df['stdev_diff_mortimp75']              = prep_df['stdev_diff_mortimp75_usd']
        # prep_df['stdev_current_repro_25_imp']        = prep_df['stdev_current_repro_25_imp_usd']
        # prep_df['stdev_current_repro_50_imp']        = prep_df['stdev_current_repro_50_imp_usd']
        # prep_df['stdev_current_repro_75_imp']        = prep_df['stdev_current_repro_75_imp_usd']
        # prep_df['stdev_current_repro_100_imp']       = prep_df['stdev_current_repro_100_imp_usd']
        # prep_df['stdev_diff_reprimp25']              = prep_df['stdev_diff_reprimp25_usd']
        # prep_df['stdev_diff_reprimp50']              = prep_df['stdev_diff_reprimp50_usd']
        # prep_df['stdev_diff_reprimp75']              = prep_df['stdev_diff_reprimp75_usd']
        # prep_df['stdev_diff_reprimp100']             = prep_df['stdev_diff_reprimp100_usd']
        # prep_df['stdev_current_growth_25_imp_all']   = prep_df['stdev_current_growth_25_imp_all_usd']
        # prep_df['stdev_current_growth_50_imp_all']   = prep_df['stdev_current_growth_50_imp_all_usd']
        # prep_df['stdev_current_growth_75_imp_all']   = prep_df['stdev_current_growth_75_imp_all_usd']
        # prep_df['stdev_current_growth_100_imp_all']  = prep_df['stdev_current_growth_100_imp_all_usd']
        # prep_df['stdev_all_current_growth_25_AHLE']  = prep_df['stdev_all_current_growth_25_AHLE_usd']
        # prep_df['stdev_all_current_growth_50_AHLE']  = prep_df['stdev_all_current_growth_50_AHLE_usd']
        # prep_df['stdev_all_current_growth_75_AHLE']  = prep_df['stdev_all_current_growth_75_AHLE_usd']
        # prep_df['stdev_all_current_growth_100_AHLE'] = prep_df['stdev_all_current_growth_100_AHLE_usd']

    # Create longitudinal chart
    if graph_options == "Over Time":
        # Apply user filters
        # Filter based on selected item
        prep_df = prep_df.query('item in @selected_item')

        # Sort data by year
        prep_df = prep_df.sort_values('year')

        # Establish x
        x = prep_df['year']

        # Match colors to waterfall values
        cost  = 'Expenditure'
        if 'Gross Margin' in selected_item:
            color = '#F7931D'
        elif cost in selected_item:
            color = '#E84C3D'
        else:
            color = '#3598DB'

        # Create AHLE (difference) value
        if display == "Difference":
            if compare == 'Ideal':
                y = prep_df['mean_diff_ideal']
                stdev = prep_df['stdev_diff_ideal']
            elif compare == 'Zero Mortality':
                y = prep_df['mean_diff_mortzero']
                stdev = prep_df['stdev_diff_mortzero']
            else:
                compare = impvmnt_factor + "- " + impvmnt_value
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_diff_mortimp25']
                    stdev = prep_df['stdev_diff_mortimp25']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_diff_mortimp50']
                    stdev = prep_df['stdev_diff_mortimp50']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_diff_mortimp75']
                    stdev = prep_df['stdev_diff_mortimp75']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_diff_mortzero']
                    stdev = prep_df['stdev_diff_mortzero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_reprimp{number_split}']
                    stdev = prep_df[f'stdev_diff_reprimp{number_split}']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_growimp{number_split}']
                    stdev = prep_df[f'stdev_diff_growimp{number_split}']

            # AHLE graph
            stdev = 1.96 * stdev    # Scale stdev to create 95% confidence
            plot_ahle_value = go.Scatter(
                x=x
                ,y=y
                ,error_y=dict(type='data' ,array=stdev)
                ,name='AHLE'
                ,line=dict(color=color)
                )
            ecs_waterfall_fig = make_subplots()
            ecs_waterfall_fig.add_trace(plot_ahle_value)
            ecs_waterfall_fig.update_layout(title=f'{reg_title} {selected_item} Over Time | {species}, {prodsys} <br><sup>Difference between Current and {compare} scenario</sup><br>',
                                            yaxis_title=display_currency,
                                            font_size=15,
                                            plot_bgcolor="#ededed",)
            ecs_waterfall_fig.update_xaxes(ticklabelmode="period", dtick = 1)

        elif display == "Side by Side":
            # Plot current value
            plot_current_value = go.Scatter(
                x=x
                ,y=prep_df['mean_current']
                ,error_y=dict(type='data' ,array=prep_df['stdev_current']*1.96)
                ,name='Current'
                ,line=dict(color=color)
                )
            if compare == 'Ideal':
                # Overlay ideal value
                plot_compare_value = go.Scatter(
                    x=x
                    ,y=prep_df['mean_ideal']
                    ,error_y=dict(type='data' ,array=prep_df['stdev_ideal']*1.96)
                    ,name=compare
                    ,line=dict(color='#00CA0F')
                    )
            elif compare == 'Zero Mortality':
                # Overlay zero mortality value
                plot_compare_value = go.Scatter(
                    x=x
                    ,y = prep_df['mean_mortality_zero']
                    ,error_y=dict(type='data' ,array=prep_df['stdev_mortality_zero']*1.96)
                    ,name=compare
                    ,line=dict(color='#00CA0F')
                    )
            else:
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_all_mort_25_imp']
                    stdev = prep_df['stdev_all_mort_25_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_all_mort_50_imp']
                    stdev = prep_df['stdev_all_mort_50_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_all_mort_75_imp']
                    stdev = prep_df['stdev_all_mort_75_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_mortality_zero']
                    stdev = prep_df['stdev_mortality_zero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_repro_{number_split}_imp']
                    stdev = prep_df[f'stdev_current_repro_{number_split}_imp']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_growth_{number_split}_imp_all']
                    stdev = prep_df[f'stdev_current_growth_{number_split}_imp_all']

                name = impvmnt_factor + "- " + impvmnt_value
                # Overlay zero mortality value
                stdev = 1.96 * stdev    # Scale stdev to create 95% confidence
                plot_compare_value = go.Scatter(
                    x=x
                    ,y=y
                    ,error_y=dict(type='data' ,array=stdev)
                    ,name=name
                    ,line=dict(color='#00CA0F')
                    )

            ecs_waterfall_fig = make_subplots()
            ecs_waterfall_fig.add_trace(plot_compare_value)
            ecs_waterfall_fig.add_trace(plot_current_value)
            ecs_waterfall_fig.update_layout(title=f'{reg_title} {selected_item} Over Time | {species}, {prodsys} <br><sup>Current and {compare} scenario</sup><br>',
                                            yaxis_title=display_currency,
                                            font_size=15,
                                            plot_bgcolor="#ededed",)
            ecs_waterfall_fig.update_xaxes(ticklabelmode="period", dtick = 1)

    # Create waterfall chart
    if graph_options == "Single Year":
        # Filter to a specific year
        prep_df = prep_df.query('year == @selected_year')

        # Select items to show - depends on species
        if species.upper() == "CATTLE":     # Cattle have draught
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Draught',
                                     'Value of Milk',
                                     'Value of Manure',
                                     'Value of Hides',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        elif 'POULTRY' in species.upper():   # Poultry have value of eggs, do not have manure or hides
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Eggs consumed',
                                     'Value of Eggs sold',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        else:   # Goats, Sheep, All Small Ruminants
            waterfall_plot_items = ('Value of Offtake',
                                     'Value of Herd Increase',
                                     'Value of Milk',
                                     'Value of Manure',
                                     'Value of Hides',
                                     'Expenditure on Feed',
                                     'Expenditure on Labour',
                                     'Expenditure on Health',
                                     # May 2023: Wudu does not want housing and captial expenses in waterfall chart
                                     # 'Expenditure on Housing',
                                     # 'Expenditure on Capital',
                                     'Gross Margin')
        waterfall_plot_items_upper = [i.upper() for i in waterfall_plot_items]
        prep_df = prep_df.loc[prep_df['item'].str.upper().isin(waterfall_plot_items_upper)]

        # Get list of items from data - may differ from list specified because not all items appear for all age/sex groups
        waterfall_plot_items_indata = list(prep_df['item'].unique())

        measure = ['relative'] * (len(waterfall_plot_items_indata) - 1) + ['total']
        x = prep_df['item']

        # Display and Compare filters
        if display == "Difference":
            # Applying the condition
            prep_df["item"] = np.where(prep_df["item"] == "Gross Margin", "Gross Margin (AHLE)", prep_df["item"])
            x = prep_df['item']
            if compare == 'Ideal':
                y = prep_df['mean_diff_ideal']
                stdev = prep_df['stdev_diff_ideal']
            elif compare == 'Zero Mortality':
                y = prep_df['mean_diff_mortzero']
                stdev = prep_df['stdev_diff_mortzero']
            else:
                compare = impvmnt_factor + "- " + impvmnt_value
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_diff_mortimp25']
                    stdev = prep_df['stdev_diff_mortimp25']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_diff_mortimp50']
                    stdev = prep_df['stdev_diff_mortimp50']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_diff_mortimp75']
                    stdev = prep_df['stdev_diff_mortimp75']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_diff_mortzero']
                    stdev = prep_df['stdev_diff_mortzero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_reprimp{number_split}']
                    stdev = prep_df[f'stdev_diff_reprimp{number_split}']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_diff_growimp{number_split}']
                    stdev = prep_df[f'stdev_diff_growimp{number_split}']

            # Create graph
            name = 'Difference'
            ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x, y)

            # Add error bars
            # Reset indicies
            x = x.reset_index(drop=True)
            y = y.reset_index(drop=True)

            # Scale standard deviation to achieve 95% confidence
            stdev = 1.96 * stdev    # Simulation results are Normally distributed

            # Get cumulative sum value for Y unless Gross Margin
            y_error_sum=[]
            for i in x.values:
                if i != 'Gross Margin (AHLE)':
                    y_error_sum = np.cumsum(y)
                elif i == 'Gross Margin (AHLE)':
                    GM_index = x[x == 'Gross Margin (AHLE)'].index[0]
                    y_error_sum[GM_index] = y[GM_index]
            # Add trace for error
            ecs_waterfall_fig.add_trace(
                go.Scatter(
                     x=x,
                     y=y_error_sum,
                     marker=dict(color='black'),
                     customdata=np.stack((y, prep_df['item']), axis=-1),
                     error_y=dict(
                        type='data',
                        array=stdev
                        ),
                     mode="markers",
                     hoverinfo='none',
                     name='95% Confidence'
                ),
            )
            # Add title
            ecs_waterfall_fig.update_layout(
                title_text=f'{reg_title} Animal Health Loss Envelope | {species}, {prodsys} <br><sup>Difference between current and {compare} values for {agesex}, {selected_year}</sup><br>',
                yaxis_title=display_currency,
                font_size=15,
                margin=dict(t=100)
                )
        else:
            if compare == 'Ideal':
                y = prep_df['mean_ideal']
                stdev = prep_df['stdev_ideal']
                name = "Ideal (solid)"
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len-.3,
                         y=y_error_sum,
                         marker=dict(color='black'),
                         customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=stdev
                            ),
                         mode="markers",
                         hoverinfo='none',
                         showlegend=False
                    ),
                )

                # Add current with lag
                y = prep_df['mean_current']
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = y,
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((y, prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                         marker=dict(color='black'),
                         customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                             type='data',
                             array=prep_df['stdev_current']
                             ),
                         mode="markers",
                         hoverinfo='none',
                         name='95% Confidence'
                    ),
                )
                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     # scattermode="group",
                #     # scattergap=0.75
                #     )

            elif compare == 'Zero Mortality':
                y = prep_df['mean_mortality_zero']
                stdev = prep_df['stdev_mortality_zero']
                name = 'Zero Mortality (solid)'
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                        x=x_len-.3,
                        y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                        error_y=dict(
                            type='data',
                            array=stdev
                        ),
                        mode="markers",
                        hoverinfo='none',
                        showlegend=False
                    ),
                )

                # Add current with lag
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = prep_df['mean_current'],
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((prep_df['mean_current'], prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=prep_df['stdev_current']
                        ),
                        mode="markers",
                        hoverinfo='none',
                        name='95% Confidence'
                    ),
                )

                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     )

            else:
                if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
                    y = prep_df['mean_all_mort_25_imp']
                    stdev = prep_df['stdev_all_mort_25_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
                    y = prep_df['mean_all_mort_50_imp']
                    stdev = prep_df['stdev_all_mort_50_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
                    y = prep_df['mean_all_mort_75_imp']
                    stdev = prep_df['stdev_all_mort_75_imp']
                elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
                    y = prep_df['mean_mortality_zero']
                    y = prep_df['stdev_mortality_zero']
                elif impvmnt_factor == 'Parturition Rate':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_repro_{number_split}_imp']
                    stdev = prep_df[f'stdev_current_repro_{number_split}_imp']
                elif impvmnt_factor == 'Live Weight':
                    number_split = impvmnt_value.split('%')[0]
                    y = prep_df[f'mean_current_growth_{number_split}_imp_all']
                    stdev = prep_df[f'stdev_current_growth_{number_split}_imp_all']

                name = impvmnt_factor + "- " + impvmnt_value + " (solid)"
                # Create numeric, dynamic x axis based off of items
                x_len = np.arange(1,len(x)+1,1)

                # Create graph
                ecs_waterfall_fig = create_ahle_waterfall_ecs(prep_df, name, measure, x_len-.3, y)
                # Add error bars
                # Reset indicies
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)

                # Scale standard deviation to achieve 95% confidence
                stdev = 1.96 * stdev    # Simulation results are Normally distributed

                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]
                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len-.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=stdev
                        ),
                        mode="markers",
                        hoverinfo='none',
                        showlegend=False

                    ),
                )

                # Add current with lag
                ecs_waterfall_fig.add_trace(go.Waterfall(
                    name = 'Current (outline)',
                    measure = measure,
                    x = x_len+.3,
                    y = prep_df['mean_current'],
                    decreasing = {"marker":{"color":"white", "line":{"color":"#E84C3D", "width":3}}},
                    increasing = {"marker":{"color":"white", "line":{"color":"#3598DB", "width":3}}},
                    totals = {"marker":{"color":"white", "line":{"color":"#F7931D", "width":3}}},
                    connector = {"line":{"dash":"dot"}},
                    customdata=np.stack((prep_df['mean_current'], prep_df['item']), axis=-1),
                    ))
                # Add error bars
                # Reset indicies
                y = prep_df['mean_current']
                x = x.reset_index(drop=True)
                y = y.reset_index(drop=True)
                # Get cumulative sum value for Y unless Gross Margin
                y_error_sum=[]
                for i in x.values:
                    if i != 'Gross Margin':
                        y_error_sum = np.cumsum(y)
                    elif i == 'Gross Margin':
                        GM_index = x[x == 'Gross Margin'].index[0]
                        y_error_sum[GM_index] = y[GM_index]

                # Add trace for error
                ecs_waterfall_fig.add_trace(
                    go.Scatter(
                         x=x_len+.3,
                         y=y_error_sum,
                        marker=dict(color='black'),
                        customdata=np.stack((y, prep_df['item']), axis=-1),
                         error_y=dict(
                            type='data',
                            array=prep_df['stdev_current']
                        ),
                        mode="markers",
                        hoverinfo='none',
                        name='95% Confidence'
                    ),
                )

                ecs_waterfall_fig.update_layout(
                    xaxis = dict(
                        tickmode = 'array',
                        tickvals = x_len,
                        ticktext = waterfall_plot_items
                    )
                )

                # ecs_waterfall_fig.update_layout(
                #     waterfallgroupgap = 0.5,
                #     )

            # Add title
            ecs_waterfall_fig.update_layout(
                title_text=f'{reg_title} Values and Costs | {species}, {prodsys} <br><sup>Current vs. {compare} scenario for {agesex}, {selected_year}</sup><br>',
                yaxis_title=display_currency,
                font_size=15,
                margin=dict(t=100),
                # legend=dict(orientation="v",
                #             xanchor="right",
                #             x=1,
                #             yanchor="bottom",
                #             y=1.02,)
                )

        # Add tooltip
        if currency == 'Birr':
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} Birr<extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} Birr'
                                            )
        elif currency == 'USD':
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} USD<extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} USD'
                                            )
        else:
            ecs_waterfall_fig.update_traces(hovertemplate='Category: %{customdata[1]}'+
                                            '<br>Value: %{customdata[0]:,.0f} <extra></extra>'+
                                            '<br>Cumulative Value: %{y:,.0f} '
                                            )

    return ecs_waterfall_fig


# Attribution Treemap
@gbadsDash.callback(
    Output('ecs-attr-treemap','figure'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-top-lvl-attr-ecs','value'),
    Input('select-dd-1-attr-ecs','value'),
    Input('select-dd-2-attr-ecs','value'),
    Input('select-dd-3-attr-ecs','value'),
    Input('select-dd-4-attr-ecs','value'),
    Input('select-graph-ahle-ecs', 'value'),
    # Input('select-year-item-switch-ecs', 'value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    Input('select-geo-view-ecs','value'),
    Input('select-region-ecs','value'),
)
def update_attr_treemap_ecs(
        prodsys,
        species,
        currency,
        top_lvl_hierarchy,
        dd1_hierarchy,
        dd2_hierarchy,
        dd3_hierarchy,
        dd4_hierarchy,
        graph_options,
        selected_year,
        selected_item,
        geo_view,
        region,
    ):
    # Data
    input_df = ecs_ahle_all_withattr

    # Geographic filter
    if geo_view.upper() == "NATIONAL":
        input_df = input_df.query("region == 'National'")
        reg_title = 'National'
    else:
        input_df = input_df.query("region == @region")
        reg_title = region

    # Production System filter
    # If All production systems, don't filter. Attribution data is not aggregated to that level.
    if prodsys == 'All Production Systems':
        input_df=input_df
    else:
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

    # Species filter
    # Goat and Sheep do not appear separately. These get all small ruminants results.
    if species == 'Goat' or species == "Sheep":
        input_df=input_df.loc[(input_df['species'] == 'All Small Ruminants')]
        species_label = 'All Small Ruminants'

    # Poultry subspecies do not appear separately. These get all poultry results.
    elif species == 'Poultry hybrid' or species == "Poultry indigenous":
        input_df=input_df.loc[(input_df['species'] == 'All Poultry')]
        species_label = 'All Poultry'
    else:
        input_df=input_df.loc[(input_df['species'] == species)]
        species_label = species

    # If currency is USD, use USD columns
    if currency == 'USD':
        # input_df['median'] = input_df['median_usd']
        input_df['mean'] = input_df['mean_usd']
        input_df['sd'] = input_df['sd_usd']
        input_df['lower95'] = input_df['lower95_usd']
        input_df['upper95'] = input_df['upper95_usd']

    # Prep data
    input_df = prep_ahle_fortreemap_ecs(input_df)

    # Create treemap
    if graph_options == "Single Year":
        # Year filter
        input_df = input_df.query(f'year == {selected_year}')

        # Hiararchy structure
        path = [top_lvl_hierarchy]
        if dd1_hierarchy != 'None':
            path +=[dd1_hierarchy]
        if dd2_hierarchy != 'None':
            path +=[dd2_hierarchy]
        if dd3_hierarchy != 'None':
            path +=[dd3_hierarchy]
        if dd4_hierarchy != 'None':
            path +=[dd4_hierarchy]

        # Set up treemap structure
        ecs_treemap_fig = create_attr_treemap_ecs(input_df, path)

        # Add title
        ecs_treemap_fig.update_layout(
            title_text=f'{reg_title} AHLE Attribution | {species_label}, {prodsys}<br><sup>{selected_year}',
            font_size=15,
            margin=dict(t=100)
            )

        # Add % of total AHLE
        # ecs_treemap_fig.data[0].texttemplate = "%{label}<br>% of Total AHLE=%{customdata[0]:,.2f}%"

        # Add tooltip
        if currency == 'Birr':
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f} Birr<extra></extra>')

        elif currency == 'USD':
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f} USD<extra></extra>')
        else:
            ecs_treemap_fig.update_traces(root_color="white",
                                          hovertemplate='Attribution=%{label}<br>Value=%{value:,.0f}<br><extra></extra>')

    # Create view over time
    # A stacked bar for each year, segmented by one of the hierarchy factors
    elif graph_options == "Over Time":
        segment_by = top_lvl_hierarchy   # For now, segment bars by selected top level component

        # Aggregate data to year and segment
        stackedbar_df = input_df.groupby(['year' ,segment_by])['mean'].sum().reset_index()

        ecs_treemap_fig = px.bar(
            stackedbar_df
            ,x='year'
            ,y='mean'
            ,color=segment_by
            ,barmode='relative'
            )
        ecs_treemap_fig.update_layout(
            title_text=f'{reg_title} AHLE Attribution over time | {species_label}, {prodsys}<br><sup>by {segment_by}',
            font_size=15,
            margin=dict(t=100)
            )
        ecs_treemap_fig.update_xaxes(title_text='')
        if currency == 'Birr':
            ecs_treemap_fig.update_yaxes(title_text='Ethiopian Birr')
        elif currency == 'USD':
            ecs_treemap_fig.update_yaxes(title_text='USD')

    # Adjust margins
    ecs_treemap_fig.update_layout(
        margin=dict(l=5, r=5, b=5),
        )

    return ecs_treemap_fig

# Update Stacked bar chart
@gbadsDash.callback(
    Output('ahle-stacked-bar-ecs','figure'),
    Input('select-prodsys-ecs','value'),
    Input('select-species-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-compare-ecs','value'),
    Input('select-factor-ecs','value'),
    Input('select-improve-ecs','value'),
    Input('select-graph-ahle-ecs', 'value'),
    # Input('select-year-item-switch-ecs', 'value'),
    Input('select-year-ecs', 'value'),
    Input('select-item-ecs', 'value'),
    )
def update_stacked_bar_ecs(
        prodsys,
        species,
        currency,
        compare,
        impvmnt_factor,
        impvmnt_value,
        graph_options,
        selected_year,
        selected_item,
    ):
    # AHLE Summary 2 - for stacked bar
    input_df = ecs_ahle_summary2

    # Rename values to match filters
    input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})

    # Set columns for stacked bar based on selections
    # Change y based on selected currency value
    if compare == 'Ideal':
       cols_birr_costs = [
      'ahle_when_nm_ideal_mean'
      ,'ahle_when_nf_ideal_mean'
      ,'ahle_when_jm_ideal_mean'
      ,'ahle_when_jf_ideal_mean'
      ,'ahle_when_am_ideal_mean'
      ,'ahle_when_af_ideal_mean'
      ]
       cols_usd_costs = [
      'ahle_when_nm_ideal_mean_usd'
      ,'ahle_when_nf_ideal_mean_usd'
      ,'ahle_when_jm_ideal_mean_usd'
      ,'ahle_when_jf_ideal_mean_usd'
      ,'ahle_when_am_ideal_mean_usd'
      ,'ahle_when_af_ideal_mean_usd'
      ]
       pretty_ahle_cost_names = {
          'ahle_when_nm_ideal_mean':'Neonatal male'
          ,'ahle_when_nm_ideal_mean_usd':'Neonatal male'

          ,'ahle_when_nf_ideal_mean':'Neonatal female'
          ,'ahle_when_nf_ideal_mean_usd':'Neonatal female'

          ,'ahle_when_jm_ideal_mean':'Juvenile male'
          ,'ahle_when_jm_ideal_mean_usd':'Juvenile male'

          ,'ahle_when_jf_ideal_mean':'Juvenile female'
          ,'ahle_when_jf_ideal_mean_usd':'Juvenile female'

           ,'ahle_when_am_ideal_mean':'Adult male'
           ,'ahle_when_am_ideal_mean_usd':'Adult male'

          ,'ahle_when_af_ideal_mean':'Adult female'
          ,'ahle_when_af_ideal_mean_usd':'Adult female'
       }

    elif compare == 'Zero Mortality':
        cols_birr_costs = [
        'ahle_when_n_mort_imp100_mean'
        ,'ahle_when_j_mort_imp100_mean'
        ,'ahle_when_am_mort_imp100_mean'
        ,'ahle_when_af_mort_imp100_mean'
        ]
        cols_usd_costs = [
        'ahle_when_n_mort_imp100_mean_usd'
        ,'ahle_when_j_mort_imp100_mean_usd'
        ,'ahle_when_am_mort_imp100_mean_usd'
        ,'ahle_when_af_mort_imp100_mean_usd'
        ]
        pretty_ahle_cost_names = {
            'ahle_when_n_mort_imp100_mean':'Neonatal'
            ,'ahle_when_n_mort_imp100_mean_usd':'Neonatal'

            ,'ahle_when_j_mort_imp100_mean':'Juvenile'
            ,'ahle_when_j_mort_imp100_mean_usd':'Juvenile'

            ,'ahle_when_am_mort_imp100_mean':'Adult male'
            ,'ahle_when_am_mort_imp100_mean_usd':'Adult male'

            ,'ahle_when_af_mort_imp100_mean':'Adult female'
            ,'ahle_when_af_mort_imp100_mean_usd':'Adult female'
        }
    else:
        if impvmnt_factor == 'Mortality' and impvmnt_value == '25%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp25_mean'
            ,'ahle_when_j_mort_imp25_mean'
            ,'ahle_when_am_mort_imp25_mean'
            ,'ahle_when_af_mort_imp25_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp25_mean_usd'
            ,'ahle_when_j_mort_imp25_mean_usd'
            ,'ahle_when_am_mort_imp25_mean_usd'
            ,'ahle_when_af_mort_imp25_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp25_mean':'Neonatal'
                ,'ahle_when_n_mort_imp25_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp25_mean':'Juvenile'
                ,'ahle_when_j_mort_imp25_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp25_mean':'Adult male'
                ,'ahle_when_am_mort_imp25_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp25_mean':'Adult female'
                ,'ahle_when_af_mort_imp25_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '50%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp50_mean'
            ,'ahle_when_j_mort_imp50_mean'
            ,'ahle_when_am_mort_imp50_mean'
            ,'ahle_when_af_mort_imp50_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp50_mean_usd'
            ,'ahle_when_j_mort_imp50_mean_usd'
            ,'ahle_when_am_mort_imp50_mean_usd'
            ,'ahle_when_af_mort_imp50_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp50_mean':'Neonatal'
                ,'ahle_when_n_mort_imp50_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp50_mean':'Juvenile'
                ,'ahle_when_j_mort_imp50_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp50_mean':'Adult male'
                ,'ahle_when_am_mort_imp50_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp50_mean':'Adult female'
                ,'ahle_when_af_mort_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '75%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp75_mean'
            ,'ahle_when_j_mort_imp75_mean'
            ,'ahle_when_am_mort_imp75_mean'
            ,'ahle_when_af_mort_imp75_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp75_mean_usd'
            ,'ahle_when_j_mort_imp75_mean_usd'
            ,'ahle_when_am_mort_imp75_mean_usd'
            ,'ahle_when_af_mort_imp75_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp75_mean':'Neonatal'
                ,'ahle_when_n_mort_imp75_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp75_mean':'Juvenile'
                ,'ahle_when_j_mort_imp75_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp75_mean':'Adult male'
                ,'ahle_when_am_mort_imp75_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp75_mean':'Adult female'
                ,'ahle_when_af_mort_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Mortality' and impvmnt_value == '100%':
            cols_birr_costs = [
            'ahle_when_n_mort_imp100_mean'
            ,'ahle_when_j_mort_imp100_mean'
            ,'ahle_when_am_mort_imp100_mean'
            ,'ahle_when_af_mort_imp100_mean'
            ]
            cols_usd_costs = [
            'ahle_when_n_mort_imp100_mean_usd'
            ,'ahle_when_j_mort_imp100_mean_usd'
            ,'ahle_when_am_mort_imp100_mean_usd'
            ,'ahle_when_af_mort_imp100_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_n_mort_imp100_mean':'Neonatal'
                ,'ahle_when_n_mort_imp100_mean_usd':'Neonatal'

                ,'ahle_when_j_mort_imp100_mean':'Juvenile'
                ,'ahle_when_j_mort_imp100_mean_usd':'Juvenile'

                ,'ahle_when_am_mort_imp100_mean':'Adult male'
                ,'ahle_when_am_mort_imp100_mean_usd':'Adult male'

                ,'ahle_when_af_mort_imp100_mean':'Adult female'
                ,'ahle_when_af_mort_imp100_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '25%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp25_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp25_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp25_mean':'Adult female'
                ,'ahle_when_af_repro_imp25_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '50%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp50_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp50_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp50_mean':'Adult female'
                ,'ahle_when_af_repro_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '75%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp75_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp75_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp75_mean':'Adult female'
                ,'ahle_when_af_repro_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Parturition Rate' and impvmnt_value == '100%':
            cols_birr_costs = [
            'ahle_when_af_repro_imp100_mean'
            ]
            cols_usd_costs = [
            'ahle_when_af_repro_imp100_mean_usd'
            ]
            pretty_ahle_cost_names = {
                'ahle_when_af_repro_imp100_mean':'Adult female'
                ,'ahle_when_af_repro_imp100_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '25%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp25_mean'
           ,'ahle_when_nf_growth_imp25_mean'
           ,'ahle_when_jm_growth_imp25_mean'
           ,'ahle_when_jf_growth_imp25_mean'
           ,'ahle_when_am_growth_imp25_mean'
           ,'ahle_when_af_growth_imp25_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp25_mean_usd'
           ,'ahle_when_nf_growth_imp25_mean_usd'
           ,'ahle_when_jm_growth_imp25_mean_usd'
           ,'ahle_when_jf_growth_imp25_mean_usd'
           ,'ahle_when_am_growth_imp25_mean_usd'
           ,'ahle_when_af_growth_imp25_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp25_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp25_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp25_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp25_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp25_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp25_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp25_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp25_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp25_mean':'Adult male'
                ,'ahle_when_am_growth_imp25_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp25_mean':'Adult female'
               ,'ahle_when_af_growth_imp25_mean_usd':'Adult female'
            }

        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '50%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp50_mean'
           ,'ahle_when_nf_growth_imp50_mean'
           ,'ahle_when_jm_growth_imp50_mean'
           ,'ahle_when_jf_growth_imp50_mean'
           ,'ahle_when_am_growth_imp50_mean'
           ,'ahle_when_af_growth_imp50_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp50_mean_usd'
           ,'ahle_when_nf_growth_imp50_mean_usd'
           ,'ahle_when_jm_growth_imp50_mean_usd'
           ,'ahle_when_jf_growth_imp50_mean_usd'
           ,'ahle_when_am_growth_imp50_mean_usd'
           ,'ahle_when_af_growth_imp50_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp50_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp50_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp50_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp50_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp50_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp50_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp50_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp50_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp50_mean':'Adult male'
                ,'ahle_when_am_growth_imp50_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp50_mean':'Adult female'
               ,'ahle_when_af_growth_imp50_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '75%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp75_mean'
           ,'ahle_when_nf_growth_imp75_mean'
           ,'ahle_when_jm_growth_imp75_mean'
           ,'ahle_when_jf_growth_imp75_mean'
           ,'ahle_when_am_growth_imp75_mean'
           ,'ahle_when_af_growth_imp75_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp75_mean_usd'
           ,'ahle_when_nf_growth_imp75_mean_usd'
           ,'ahle_when_jm_growth_imp75_mean_usd'
           ,'ahle_when_jf_growth_imp75_mean_usd'
           ,'ahle_when_am_growth_imp75_mean_usd'
           ,'ahle_when_af_growth_imp75_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp75_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp75_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp75_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp75_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp75_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp75_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp75_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp75_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp75_mean':'Adult male'
                ,'ahle_when_am_growth_imp75_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp75_mean':'Adult female'
               ,'ahle_when_af_growth_imp75_mean_usd':'Adult female'
            }
        elif impvmnt_factor == 'Live Weight' and impvmnt_value == '100%':
            cols_birr_costs = [
           'ahle_when_nm_growth_imp100_mean'
           ,'ahle_when_nf_growth_imp100_mean'
           ,'ahle_when_jm_growth_imp100_mean'
           ,'ahle_when_jf_growth_imp100_mean'
           ,'ahle_when_am_growth_imp100_mean'
           ,'ahle_when_af_growth_imp100_mean'
           ]
            cols_usd_costs = [
           'ahle_when_nm_growth_imp100_mean_usd'
           ,'ahle_when_nf_growth_imp100_mean_usd'
           ,'ahle_when_jm_growth_imp100_mean_usd'
           ,'ahle_when_jf_growth_imp100_mean_usd'
           ,'ahle_when_am_growth_imp100_mean_usd'
           ,'ahle_when_af_growth_imp100_mean_usd'
           ]
            pretty_ahle_cost_names = {
               'ahle_when_nm_growth_imp100_mean':'Neonatal male'
               ,'ahle_when_nm_growth_imp100_mean_usd':'Neonatal male'

               ,'ahle_when_nf_growth_imp100_mean':'Neonatal female'
               ,'ahle_when_nf_growth_imp100_mean_usd':'Neonatal female'

               ,'ahle_when_jm_growth_imp100_mean':'Juvenile male'
               ,'ahle_when_jm_growth_imp100_mean_usd':'Juvenile male'

               ,'ahle_when_jf_growth_imp100_mean':'Juvenile female'
               ,'ahle_when_jf_growth_imp100_mean_usd':'Juvenile female'

                ,'ahle_when_am_growth_imp100_mean':'Adult male'
                ,'ahle_when_am_growth_imp100_mean_usd':'Adult male'

               ,'ahle_when_af_growth_imp100_mean':'Adult female'
               ,'ahle_when_af_growth_imp100_mean_usd':'Adult female'
            }

    # -----------------------------------------------------------------------------
    # Base plot
    # -----------------------------------------------------------------------------
    # Apply year filter
    if graph_options == "Single Year":
        input_df = input_df.loc[input_df['year'] == selected_year]
    else:
        input_df = input_df.loc[input_df['year'] == 2021]

    # Structure for plot
    stackedbar_df = prep_ahle_forstackedbar_ecs(input_df, cols_birr_costs, cols_usd_costs, pretty_ahle_cost_names)

    # Apply production system filter
    stackedbar_df = stackedbar_df.loc[stackedbar_df['production_system'] == prodsys]

    # Apply species filter
    stackedbar_df = stackedbar_df.loc[stackedbar_df['species'] == species]

    x = stackedbar_df['species']

    # Change y based on selected currency value
    if currency == 'Birr':
        yaxis_title = 'Ethiopian Birr'
        y = stackedbar_df['cost_birr']
        text = stackedbar_df['label_birr']
    elif currency == 'USD':
        yaxis_title = 'USD'
        y = stackedbar_df['cost_usd']
        text = stackedbar_df['label_usd']

    # Color
    color = stackedbar_df['AHLE Due To']

    # Create Stacked Bar
    ahle_bar_ecs_fig = create_stacked_bar_ecs(stackedbar_df, x, y, text, color, yaxis_title)

    if compare == 'Ideal' or compare == 'Zero Mortality':
        ahle_bar_ecs_fig.update_layout(
            title_text=f'AHLE contributions by Age Group | {species}, {prodsys} <br><sup>{compare} scenario</sup><br>',
            font_size=15
            )
    else:
        ahle_bar_ecs_fig.update_layout(
            title_text=f'AHLE contributions by Age Group | {species}, {prodsys} <br><sup>{impvmnt_factor} {impvmnt_value} improvement scenario</sup><br>',
            font_size=15
            )

    # # Add tooltip
    # if currency == 'Birr':
    #     ahle_bar_ecs_fig.update_traces(hovertemplate='Category=%{color}<br>Value=%{y:,.0f} Birr<extra></extra>')
    # elif currency == 'USD':
    #     ahle_bar_ecs_fig.update_traces(hovertemplate='Category=%{color}<br>Value=%{y:,.0f} USD<extra></extra>')

    return ahle_bar_ecs_fig

@gbadsDash.callback(
    Output('ecs-wei-chart-1','figure'),
    Output('ecs-wei-chart-2','figure'),
    Input('select-species-ecs','value'),    # Dummy input
    )
def update_wei_display_ecs(species):
    # Chart 1: GDP
    wei_chart_1 = create_wei_chart(
        input_df=wei_ethiopia_raw
        ,plot_xvar='production_change_pct'
        ,plot_yvar='gdp_change_pct'
        ,plot_color='blue'
        ,interpolation_kind='linear'
        )
    wei_chart_1.update_layout(
        title_text='GDP change due to productivity change by scenario <br><sup>Cattle and small ruminants combined</sup>'
        ,font_size=15

    	,xaxis_title='% Change in Production'
        ,xaxis_tickformat='.0%'

    	,yaxis_title='% GDP Change'
        ,yaxis_tickformat='.1%'

        ,plot_bgcolor="#ededed"
        )

    # Chart 2: Economic surplus
    wei_chart_2 = create_wei_chart(
        input_df=wei_ethiopia_raw
        ,plot_xvar='production_change_pct'
        ,plot_yvar='economic_surplus_mlnusd'
        ,plot_color='green'
        ,interpolation_kind='linear'
        )
    wei_chart_2.update_layout(
        title_text='Economic surplus due to productivity change by scenario <br><sup>Cattle and small ruminants combined</sup>'
        ,font_size=15

    	,xaxis_title='% Change in Production'
        ,xaxis_tickformat='.0%'

    	,yaxis_title='Economic Surplus (Million USD)'
        ,yaxis_tickformat='$,.1f'

        ,plot_bgcolor="#ededed"
        )
    return wei_chart_1 ,wei_chart_2

# Update subnational map
@gbadsDash.callback(
    Output('ecs-map','figure'),
    Input('select-species-ecs','value'),
    Input('select-agesex-ecs', 'value'),
    Input('select-prodsys-ecs','value'),
    Input('select-map-display-ecs','value'),
    Input('select-currency-ecs','value'),
    Input('select-map-denominator-ecs','value'),
    )
def update_map_display_ecs(species, group, prodsys, item, currency, denominator):
    if species.upper() != 'CATTLE':
        ecs_map_fig = go.Figure()
        ecs_map_fig.update_layout(
               xaxis =  { "visible": False },
               yaxis = { "visible": False },
               annotations = [
                   {
                       "text": "Subnational estimates are currently only available for cattle.",
                       "xref": "paper",
                       "yref": "paper",
                       "showarrow": False,
                       "font": {
                           "size": 28
                       }
                   }
               ]
           )
    else:
        # Ethiopia subnational level map data from S3
        geojson_ecs_df = geojson_ecs.copy()
        # geojson_ecs_df = gpd.read_file('<filename>.geojson')

        # Set location based on the granularity level of data - currently Region
        featureid = 'ADM1_EN'
        location = 'region'

        # Set the featureid key needed for the choropleth mapbox map
        featurekey = (f'properties.{featureid}')

        # Read in data and apply filters
        input_df = ecs_ahle_summary

        # Filter based on species - Currently only have Cattle for 2021
        input_df = input_df.loc[(input_df['species'] == 'Cattle')]

        # Remove 'National' for regional view
        input_df = input_df.query("region != 'National'")

        # Production System filter
        # Rename values to match filters
        input_df['production_system'] = input_df['production_system'].replace({'Overall': 'All Production Systems'})
        input_df=input_df.loc[(input_df['production_system'] == prodsys)]

        # Age/sex filter
        input_df=input_df.loc[(input_df['group'] == group)]

        if item == 'Ideal Gross Margin' or item == 'Animal Health Loss Envelope':
            item_filter = 'Gross Margin'
        else:
            item_filter = item
        input_df = input_df.query("item == @item_filter")

        # Set values based on selected currency and denominator values
        # If currency is USD, use USD columns
        display_currency = 'Ethiopian Birr'
        if denominator.upper() == 'PER KG BIOMASS':
            if currency == 'USD':
                display_currency = 'USD'
                input_df['mean_current'] = input_df['mean_current_perkgbiomass_usd']
                input_df['mean_ideal'] = input_df['mean_ideal_perkgbiomass_usd']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_perkgbiomass_usd']
            else:
                input_df['mean_current'] = input_df['mean_current_perkgbiomass']
                input_df['mean_ideal'] = input_df['mean_ideal_perkgbiomass']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_perkgbiomass']

        else:
            if currency == 'USD':
                display_currency = 'USD'
                input_df['mean_current'] = input_df['mean_current_usd']
                input_df['mean_ideal'] = input_df['mean_ideal_usd']
                input_df['mean_diff_ideal'] = input_df['mean_diff_ideal_usd']

        # Color scale by current, ideal or AHLE
        if item == 'Ideal Gross Margin':
            color_by = 'mean_ideal'
        elif item == 'Animal Health Loss Envelope':
            color_by = 'mean_diff_ideal'
        else:
            color_by = 'mean_current'

        input_df = input_df.sort_values(by=[f'{color_by}'])

        # Set color scale to match waterfall colors
        if "GROSS MARGIN" in item.upper() or "ANIMAL HEALTH LOSS ENVELOPE" in item.upper():
            color_scale = [(0, "#F7F9FB"), (0.5, "#F7C080"), (1, "#F7931D")]
        elif "VALUE" in item.upper():
            color_scale = [(0, "#ecf5fc"), (0.5, "#88c2ea"), (1, "#3598db")]
        elif "COST" in item.upper():
            color_scale = [(0, "#fdeeec"), (0.5, "#f08d83"), (1, "#E84C3D")]

        ecs_map_fig = create_map_display_ecs(input_df, geojson_ecs_df, location, featurekey, color_by, color_scale)

        # Set min to 0
        if min(input_df[f'{color_by}']) < 0:
            ecs_map_fig.update_layout(coloraxis=dict(cmax=max(input_df[f'{color_by}']), cmin=0))
        else:
            ecs_map_fig.update_layout(coloraxis=dict(cmax=max(input_df[f'{color_by}']), cmin=min(input_df[f'{color_by}'])))

        # Adjust margins
        ecs_map_fig.update_layout(
            margin=dict(l=5, r=5, b=5),
            )

        # Add title
        ecs_map_fig.update_layout(
            title_text=f'{item} in {currency} {denominator} by subnational state | {group} Cattle, {prodsys} in 2021',
            font_size=15
            )

        # Update legend title
        ecs_map_fig.update_layout(
            coloraxis_colorbar=dict(
                title=f"{display_currency}",
                )
            )

        # Disable mouse zooming at request of Ethiopia users
        #!!! Unknown why this does not work.
        ecs_map_fig.update_layout(dragmode=False)

        # TODO: Refine tooltip
        # # Update tooltip
        # if currency == 'Birr':
        #     ecs_map_fig.update_traces(hovertemplate='subnational state: %{location}'+
        #                                     '<br>%{featurekey}: %{y} Birr <extra></extra>',
        #                                     )
        #     # Tried x, color, item, color_by, text, featurekey, y
        # elif currency == 'USD':
        #     ecs_map_fig.update_traces(hovertemplate='subnational state: %{location}'+
        #                                     '<br>%{item}: %{color:,.0f} USD <extra></extra>'+
        #                                     ''
        #                                     )

    return ecs_map_fig

#%% 6. RUN APP
#############################################################################################################

if __name__ == "__main__":
   # NOTE: These statements are not executed when in gunicorn, because in gunicorn this program is loaded as module

   # use_port = fa.get_open_port()  # selects first unused port >= 8050
   use_port = 8050                 # set to fixed fixed number

   fa.run_server(app, use_port, debug=True)

def returnApp():
    """
    This function is used to create the app and return it to waitress in the docker container
    """
    # If DASH_BASE_URL is set, use DispatcherMiddleware to serve the app from that path
    if 'DASH_BASE_URL' in os.environ:
        from werkzeug.middleware.dispatcher import DispatcherMiddleware
        app.wsgi_app = DispatcherMiddleware(Flask('dummy_app'), {
            os.environ['DASH_BASE_URL']: app.server
        })
        # Added redirect to new path
        @app.wsgi_app.app.route('/')
        def redirect_to_dashboard():
            return redirect(os.environ['DASH_BASE_URL'])
        return app.wsgi_app

    # If no DASH_BASE_URL is set, just return the app server
    return app.server
